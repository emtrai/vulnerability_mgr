/**
 * Copyright (C) 2022 Anh Huy Ngo - All Rights Reserved
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * 
 * Author: Anh Ngo
 * Created Date: 
 */

////////////////////////////////////////////////////////////////////
// MODULE LOADING
////////////////////////////////////////////////////////////////////

var ERR = require("../errno");
var COMMON = require("../common");
var MODULEDB = require('../model/module/module_db');
var MODULE_CVE_DB = require('../model/module/module_cve_db');
var PROJECT_MODULE_DB = require('../model/project/project_module_db');
var TAGS = require('./tags_ctrl');

////////////////////////////////////////////////////////////////////
// GLOBAL VARIABLES
////////////////////////////////////////////////////////////////////


var log = require("../log").build("modulectrl");

var INIT_MODULE_FPATH = "cve_module";
const SEPARATE_MODULE_FIELDS = ";";

////////////////////////////////////////////////////////////////////
// FUNCTION
////////////////////////////////////////////////////////////////////

function getList(){
    log.d("Get list of module")
    return MODULEDB.getList();
}

function getListModuleWithProject(callback){
    log.d("Get list of module, with project info")
    MODULEDB.getList().then(items => {
        let requests = items.map (item => {
            log.d(`getList callback ${item}`);
            return new Promise((resolve, reject) => {
                PROJECT_MODULE_DB.getProjectListOfModule(item.id).then(projects => {
                    log.d(`getProjectListOfModule callback ${projects}`);
                    log.d(projects);
                    item.projects = projects;
                    resolve(item);
                });
            });
        });

        Promise.all(requests)
            .then(function(){
                // callback(err, items);
                let requestsCountCVE = items.map (item => {
                    log.d(`getProjectListOfModule all callback ${item}`);
                    return new Promise((resolve, reject) => {
                        MODULE_CVE_DB.countCVE(item.id).then(noCVE => {
                            item.noCVE = noCVE;
                            resolve(item);
                        });
                    });
                });
                Promise.all(requestsCountCVE).then(()=>{
                    callback(ERR.ErrNone, items);
                });
            })
    });
}


function add(name, desc, tags, versions, keywords, callback){
    log.d(`add module ${name}`);
    var item = MODULEDB.buildItem();
    item.name = name;
    if (!COMMON.isEmpty(desc)) item.desc = desc;

    if (!COMMON.isEmpty(tags)){
        tags.forEach(element => {
            item.tags.push(element);
        });
    }
    if (!COMMON.isEmpty(versions)){
        versions.forEach(element => {
            item.versions.push(element);
        });
    }
    if (!COMMON.isEmpty(keywords)){
        keywords.forEach(element => {
            item.keywords.push(element);
        });
    }
    // MODULEDB.add(item, function(ret, item, ret_msg){
    //     item.tags.forEach(element => {
    //         TAGS.addTag(element);
    //     });
    //     callback(ret, item, ret_msg);
    // });
    MODULEDB.add(item)
        .then(item => {
            item.tags.forEach(element => {
                TAGS.addTag(element);
            });
            callback(ERR.ErrNone, item);
        })
        .catch(err=>{
            var [msg, code, data, err] = COMMON.parseError(err);
            log.d(`Add module db error ${msg}, code ${code}`);
            callback(code, data);
        })
        ;
    // return MODULEDB.add(item);
}

function getModule(name){
    return MODULEDB.getModule(name);
}

function updateProject(id, name, desc, tags){
    
}


/**
 * Module keyword map
 * Key: keyword
 * Value: list of module's id
 */
var KEYWORK_MAP = {}
var KEYWORM_MAP_INIT = false;
function getKeyworkdsMap(){
    log.d('getKeyworkdsMap');
    return new Promise((resolve, reject) => {
        if (KEYWORM_MAP_INIT){
            log.d("Already init, return map");
            resolve(KEYWORK_MAP);
        }
        else{
            log.d("not init yet, build keywords map");
            buildKeyWordsMap().then(maps=>{
                log.d("build keyword maps done");
                resolve(maps);
            })
        }
    });
}

function buildKeyWordsMap(){
    log.d('buildKeyWordsMap');
    return new Promise((resolve, reject) => {
        getList().then(items => {
            log.d("getList callback");
            if (!COMMON.isEmpty(items)){
                if (!KEYWORM_MAP_INIT){
                    log.d("Not init yet, do init");
                    items.forEach(item => {
                        updateKeyWordsMapFromItem(item);
                    });
                    
                }
                log.dumpDict(KEYWORK_MAP, "KEYWORK_MAP");
            }
            else{
                log.i("Not found any module");
                
            }
            KEYWORM_MAP_INIT = true;
            resolve(KEYWORK_MAP);
            
        });
    });
}

function updateKeyWordsMap(keyword, moduleId){

    log.d(`updateKeyWordsMap '${keyword}: ${moduleId}`);
    keyword = keyword.toLowerCase();
    if (!KEYWORK_MAP.hasOwnProperty(keyword)){
        KEYWORK_MAP[keyword] = [moduleId]
    }
    if (!KEYWORK_MAP[keyword].includes(moduleId)){
        KEYWORK_MAP[keyword].push(moduleId);
    }
}

function updateKeyWordsMapFromItem(item){

    log.d(`updateKeyWordsMapFromItem '${item.toString()}`);
    updateKeyWordsMap(item.name, item.id);
    item.keywords.forEach(keyword => {
        updateKeyWordsMap(keyword, item.id);

    });
}


/**
 * Parse description to get list of module (_id)
 * @param {*} desc 
 * @returns List of module's id
 */
function parseToGetModuleList(desc){
    return new Promise((resolve, reject) => {
        var moduleList = [];
        var desc_lower = desc.toLowerCase();
        log.d(`parseToGetModuleList: '${desc}'`);
        getKeyworkdsMap().then(maps => {
            log.d("get keywordmap ok");
            if (!COMMON.isEmpty(maps)){
                for (var keyword in maps) {
                    log.d(`keyword ${keyword}`);
                    var pos = desc_lower.indexOf(keyword);
                    if (pos >= 0){
                        Array.prototype.push.apply(moduleList, KEYWORK_MAP[keyword]);
                        // moduleList.push(element);
                    }       
                }
            }
            
        
            // log.d(`Found : ${moduleList}`);
            log.dumpArray(moduleList, "found module list");
            resolve(moduleList);
        });
    });
    // var moduleList = [];
    // var desc_lower = desc.toLowerCase();
    // log.d(`parseToGetModuleList: '${desc}'`)
    // getKeyworkdsMap().then(maps => {
    //     for (var keyword in maps) {
    //         log.d(`keyword ${keyword}`);
    //         var pos = desc_lower.indexOf(keyword);
    //         if (pos >= 0){
    //             Array.prototype.push.apply(moduleList, KEYWORK_MAP[keyword]);
    //             // moduleList.push(element);
    //         }       
    //     }
    
    //     // log.d(`Found : ${moduleList}`);
    //     log.dumpArray(moduleList, "found module list");
    // });
    // for (var keyword in KEYWORK_MAP) {
    //     log.d(`keyword ${keyword}`);
    //     var pos = desc_lower.indexOf(keyword);
    //     if (pos >= 0){
    //         Array.prototype.push.apply(moduleList, KEYWORK_MAP[keyword]);
    //         // moduleList.push(element);
    //     }       
    // }

    // // log.d(`Found : ${moduleList}`);
    // log.dumpArray(moduleList, "found module list");
    // return moduleList;
}


function init(){
    log.i("Init");
    var promise = getList();
    promise.then(items => {
        if (COMMON.isEmpty(items)){
            var fpath = COMMON.getPathFromRoot(INIT_MODULE_FPATH);
            log.i(`init, read from file ${fpath}'`);
            COMMON.readFileLineByLine(fpath)
                .then((lines) => {
                    log.d(`read line cb: ${lines}`);
                    if (!COMMON.isEmpty(lines)){
                        lines.forEach(line => {
                            line = line.trim();
                            log.d(`Line ${line}`);
                            if (!COMMON.isEmpty(line) && !line.startsWith("#")){
                                const [name, desc, strversions, strtags,strkeywords] = line.split(SEPARATE_MODULE_FIELDS);
                                log.d(`name: '${name}'`);
                                log.d(`desc: '${desc}'`);
                                log.d(`strversions: '${strversions}'`);
                                log.d(`strtags: '${strtags}'`);
                                log.d(`strkeywords: '${strkeywords}'`);
                                var versions = COMMON.getListFromString(strversions);
                                var tags = COMMON.getListFromString(strtags);
                                var keywords = COMMON.getListFromString(strkeywords);
                                add(name, desc, tags, versions, keywords, function(ret, item){
                                    log.d(`Added module '${name}', id '${item}'`);
                                    updateKeyWordsMapFromItem(item);
                                });
                            }
                            else{
                                log.d(`Skip`);
                            }
                        });
                    }
                    else{
                        log.e("Read module from file failed");
                    }
                })
                .catch((ret) => {
                    log.e(`Read ${fpath} failed: ${ret}`);
                    })
                ;
        }
        else{
            buildKeyWordsMap();
        }
    });
    promise.catch(err => {

    });

    
}

init();
////////////////////////////////////////////////////////////////////
// MODULE EXPORT
////////////////////////////////////////////////////////////////////
exports.getList = getList;
exports.add = add;
exports.getModule = getModule;
exports.parseToGetModuleList = parseToGetModuleList;
exports.getListModuleWithProject = getListModuleWithProject;