/**
 * Copyright (C) 2022 Anh Huy Ngo - All Rights Reserved
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * 
 * Author: Anh Ngo
 * Created Date: 
 */

////////////////////////////////////////////////////////////////////
// MODULE LOADING
////////////////////////////////////////////////////////////////////

var ERR = require("../errno");
var COMMON = require("../common");
var log = require("../log").build("cve_ctrl");
var ModUuid = require('uuid');
var MODULE_CTRL = require("./module_ctrl");
var CVE = require("../model/cve/cve_db");
var CVE_MODULE_DB = require("../model/cve/cve_module_db");
var PRJ_MODULE_DB = require("../model/project/project_module_db");
var PRJ_CVE_DB = require("../model/project/project_cve_db");

const {
    Worker
  } = require('worker_threads');
////////////////////////////////////////////////////////////////////
// GLOBAL VARIABLES
////////////////////////////////////////////////////////////////////


const IMPORT_NIST = "nist";

const IMPORT_STATE_IDLE = 0;
const IMPORT_STATE_PARSE = 1;
const IMPORT_STATE_DB = 2;
const IMPORT_STATE_DONE = 3;
const IMPORT_STATE_ERROR = -1;

function getImportReq(fpath, type){
    return {
        path:fpath,
        type:type,
        id:ModUuid.v1(),
        state:IMPORT_STATE_IDLE
    }
}

const requestList = new Map();

////////////////////////////////////////////////////////////////////
// FUNCTION
////////////////////////////////////////////////////////////////////

function add2ReqList(req){
    requestList.set(req.id, req);
}


function doImport(fpath, type, callback){
    return new Promise(function(resolve, reject){
        var req = getImportReq(fpath, type);
        add2ReqList(req);
        // req.state = IMPORT_STATE_PARSE;
        const worker = new Worker('./controller/importer/nist_importer.js', {workerData:{
            req
        }});
        worker.on("message", resolve);
        worker.on("error", reject);
        worker.on("exit", (code)=>log.e(`Exit code: ${code}`));
        // if (callback != null)
        //     callback(req)
    });
}

async function importCveFile(fpath, type, callback){
    doImport(fpath, type, callback)
        .then((result) => log.e(`Result of import ${result}`))
        .catch(error => log.e(error))
}


function addCVE(cveitem){
    log.d(`add CVE ${cveitem.toString()}`);
    return new Promise((resolve, reject) => {
        CVE.add(cveitem)
            .then((item) => {
                log.d(`Added cve ${cveitem.vul_id} done, add module-cve mapping list`);
                return MODULE_CTRL.parseToGetModuleList(item.getDesc());
                // return new Promise((resolve2, reject2) => {
                //     MODULE_CTRL.parseToGetModuleList(item.getDesc())
                //         .then(moduleList => {
                //             log.d(`parseToGetModuleList callback`);
                //             resolve2(moduleList)
                //         })
                //         .catch(err=>{
                //             log.d(`parseToGetModuleList callback err ${err}`);
                //         })
                //         ;
                // });
                // MODULE_CTRL.parseToGetModuleList(item.getDesc()).then(moduleList=>{
                //     log.dumpArray(moduleList, "moduleList");
                //     if (!COMMON.isEmpty(moduleList)){
                //         log.dumpArray(moduleList, "module list");
                //         var requests = moduleList.map(element => {
                //             log.d(`map cve id ${item.id} and ${element}`);
                //             return CVE_MODULE_DB.add(item.id, element, []);
                //         })
                        
                //         Promise.all(requests).then(() => {
                //             log.d("Added all mapping");
                //             // resolve(cveitem);


                //         });
                //     }
                //     else{
                //         log.i(`Not found any module list for cve ${cveitem.vul_id} `);
                //         resolve(cveitem);
                //     }
                // });
                
                // var moduleList = MODULE_CTRL.parseToGetModuleList(item.getDesc());
                // if (!COMMON.isEmpty(moduleList)){
                //     log.dumpArray(moduleList, "module list");
                //     var requests = moduleList.map(element => {
                //         log.d(`map cve id ${item.id} and ${element}`);
                //         return CVE_MODULE_DB.add(item.id, element, []);
                //     })
                    
                //     Promise.all(requests).then(() => {
                //         log.d("Added all mapping");
                //         resolve(cveitem);
                //     });
                // }
                // else{
                //     log.i(`Not found any module list for cve ${cveitem.vul_id} `);
                //     resolve(cveitem);
                // }
            })
            .then(moduleList => {
                log.dumpArray(moduleList, "moduleList");
                if (!COMMON.isEmpty(moduleList)){
                    log.dumpArray(moduleList, "module list");
                    var requests = moduleList.map(element => {
                        log.d(`map cve id ${cveitem.id} and ${element}`);
                        return CVE_MODULE_DB.add(cveitem.id, element, []);
                    })
                    return new Promise((resolve2, reject2) => Promise.all(requests).then(resolve2(moduleList)));
                    // Promise.all(requests).then(() => {
                    //     log.d("Added all mapping");
                    //     // resolve(cveitem);

                    // });
                }
                else{
                    log.i(`Not found any module list for cve ${cveitem.vul_id} `);
                    resolve(cveitem);
                }
            })
            .then(function(moduleList){
                log.d("Added all mapping, check project");
                log.dumpArray(moduleList, "module list");
                var projectList = [];
                let requests = moduleList.map(moduleid=>{
                    return new Promise((resolve3, reject3) => {
                        PRJ_MODULE_DB.getProjectListOfModule(moduleid)
                            .then(prjlist => {
                                log.dumpArray(prjlist, "prjlist");
                                prjlist.forEach(prj => {
                                    if (!projectList.includes(prj.projectId)){
                                        projectList.push(prj.projectId);
                                    }
                                })
                                resolve3(projectList);
                                // projectList.push.apply(projectList, prjlist);
                            })
                            ;
                    }) 
                });

                // Promise.all(requests).then(function(){
                //     log.dumpArray(projectList, "get all project list callback");
                    
                //     resolve(cveitem);
                // });
                return new Promise((resolve4, reject4) => Promise.all(requests)
                        .then(function(){
                            log.dumpArray(projectList, "ALL projectList");
                            resolve4(projectList)}
                        ));
                
                // resolve(cveitem);
            })
            .then(function(projectList){
                log.dumpArray(projectList, "get all project list callback");
                let requests = projectList.map(prjid => {
                    log.d(`Add map for prj ${prjid} - cve ${cveitem.id}`);
                    return PRJ_CVE_DB.add(prjid, cveitem.id);
                });
                // resolve(cveitem);
                Promise.all(requests).then(function(){
                    // log.dumpArray(projectList, "get all project list callback");
                    log.d(`Added all mapping prj-cve for cve ${cveitem.id} - ${cveitem.vul_id}`);
                    
                    resolve(cveitem);
                });
            })
            .catch(err => {
                var retmsg = `Add cve ${cveitem.vul_id} failed, ${err}`;
                log.e(retmsg);
                reject(COMMON.buildError(retmsg, ERR.ErrFailed, cveitem, err));
            });
    });
}

function getCVEList(keyword, page, perpage){
    log.d(`getCVEList, '${keyword}', ${page}, ${perpage}`);
    return new Promise((resolve, reject) => {
        CVE.search(keyword, page, perpage)
            .then(function(result){
                var cves = result.cves;
                var totalpages = result.totalpages;
                log.d(`search callback, totalpages ${totalpages}`);
                if (!COMMON.isEmpty(cves)){
                    // var allModuleList = []
                    let requests = cves.map(cve => {
                        return new Promise((resolve2, reject2) => {
                            log.d(`Get module list for cve ${cve.id} (${cve.vul_id})`);
                            CVE_MODULE_DB.getModuleListOfCVE(cve.id)
                                .then(moduleList => 
                                    {
                                        log.d("Get module list callback");
                                        log.dumpArray(moduleList, `Module list of ${cve.cve_id}`);
                                        cve.modules = moduleList;
                                        // moduleList.forEach(element => {
                                        //     if (!allModuleList.includes(element.moduleId)){
                                        //         allModuleList.push(element.moduleId);
                                        //     }
                                        // })
                                        resolve2(cve);
                                    });
                        });
                    });

                    return new Promise ((resolve3, reject3) => {
                        Promise.all(requests)
                        .then(function(){
                            // log.dumpArray(allModuleList, "Got all module list callback");
                            resolve3(result);
                        })
                        .catch(err => {
                            log.e(`Got module list of cve failed ${err}`);
                        })
                        ;
                    });
                }
                else{
                    resolve(result);
                }
                // var idx = (page - 1)*perpage + 1;
                // res.json({
                //     totalpages:totalpages,
                //     page:page,
                //     startIdx:idx,
                //     cves:cves.map(function(cve){
                //         return {
                //             idx:idx++,
                //             vul_id:cve.vul_id,
                //             cve_id:cve.cve_id,
                //             desc:cve.getDesc(),
                //             ref:cve.getRef(),
                //             tag:cve.getTag(),
                //             source:cve.source,
                //             module:cve.module,
                //         }})                    
                // });
            })
            .then(result => {
                var cves = result.cves;
                let requests = cves.map(cve => {
                    return new Promise((resolve4, reject4) => {
                        log.d(`Get prj list for cve ${cve.id} (${cve.vul_id})`);
                        PRJ_CVE_DB.getProjectListOfCve(cve.id)
                            .then(projectList => 
                                {
                                    log.d("Get prj list callback");
                                    log.dumpArray(projectList, `Prj list of ${cve.cve_id}`);
                                    cve.projects = projectList;
                                    // moduleList.forEach(element => {
                                    //     if (!allModuleList.includes(element.moduleId)){
                                    //         allModuleList.push(element.moduleId);
                                    //     }
                                    // })
                                    resolve4(cve);
                                });
                    });
                });
                Promise.all(requests)
                        .then(function(){
                            // log.dumpArray(allModuleList, "Got all module list callback");
                            resolve(result);
                        })
                        .catch(err => {
                            log.e(`Got Prj list of cve failed ${err}`);
                        })
                        ;

            })
            ;
    });
}

////////////////////////////////////////////////////////////////////
// MODULE EXPORT
////////////////////////////////////////////////////////////////////
exports.importCve = importCveFile;
exports.addCVE = addCVE;
exports.getCVEList = getCVEList;