/**
 * Copyright (C) 2022 Anh Huy Ngo - All Rights Reserved
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * 
 * Author: Anh Ngo
 * Created Date: 
 * 
 * 
 * Brief: Importing shall be executed in seprate processes (fork), to avoid impact to server
 * 
 * 
 */

////////////////////////////////////////////////////////////////////
// MODULE LOADING
////////////////////////////////////////////////////////////////////

var ERR = require("../errno");
var COMMON = require("../common");
var CONFIG = require("../config");
var UUID = require('uuid');
var MODULE_CTRL = require("./module_ctrl");
var PROJECT_CTRL = require("./project_ctrl");
var CVE_CTRL = require("./cve_ctrl");
var CVE = require("../model/cve/cve_db");
var CVE_MODULE_DB = require("../model/module/module_cve_db");
var PRJ_MODULE_DB = require("../model/project/project_module_db");
var PRJ_CVE_DB = require("../model/project/project_cve_db");
var CVE_IMPORT_DB = require("../model/cve/cve_import_db");

var PATH = require('path');
var FS = require('fs');

const {
    Worker
  } = require('worker_threads');
////////////////////////////////////////////////////////////////////
// GLOBAL VARIABLES
////////////////////////////////////////////////////////////////////

/**
 * Logging object
 */
var log = require("../log").build("cve_import_ctrl");


const DEBUG = CONFIG.DEBUG;

// TODO: Add more
// TODO: consider to add to separate/config file???
const IMPORT_NIST = "nist";
const IMPORT_SOURCE_UNKNOWN = "unknown";

// list of importer
const IMPORTER_FILE_LIST = {
    [IMPORT_NIST]:"nist_importer.js"
}

const IMPORT_FILE_ROOT = "importer"

// Status of importing
const IMPORT_STATE_IDLE = 0; // idle, do nothing
const IMPORT_STATE_PREPARE = 1; // preparation phase
const IMPORT_STATE_PARSE = 2; // parsing/updating phase
const IMPORT_STATE_DONE = 3; // Import done
const IMPORT_STATE_ERROR = -1; // import error


// Caching import request
// key: import id, value: import request
var requestList = {}


const IMPORT_SUMMARIZE_FNAME = "summarize";
const IMPORT_VUL_INFO_FNAME = "vul_import_info";


// status of adding vul: dup, added, error, etc.
const IMPORT_VUL_STATUS_DUP="duplicated";
const IMPORT_VUL_STATUS_EXIST="exist";
const IMPORT_VUL_STATUS_ADDED="added";
const IMPORT_VUL_STATUS_ERR="error";
const IMPORT_VUL_STATUS_UNKNOWN="unknown";


////////////////////////////////////////////////////////////////////
// FUNCTION
////////////////////////////////////////////////////////////////////

// TODO: check/validate paramaters, data carefully

/**
 * Build Import request, this request shall be exchanged between main server and importer processes
 * @param {*} fpath Path to uploaded/imported file
 * @param {*} source Source, i.e. nist
 * @param {*} title Title of importing, just used for hint of import if need
 * @param {*} projects List of project Ids. Vul/CVE shall be assigned for those projects
 * @param {*} modules List of modules (format: name[:version]). Vul/CVE shall be assigned for those module
 * @returns 
 */
function buildImportReq(fpath="", source="", title="", projects=[], modules=[]){
    var item =  {
        path:fpath, // path to files to be analyzed
        workingDir:null, // path to working directory. Data generated when importing shall be stored here
        source:source, // source of data, like nist
        //FIXME: TODO: Is it risk of duplicate? May resolve by checking id with database, if it exists, generate new one. Should have timeout
        // Auto generate new id string, not reuse id generation by database, which I don't prefer, because we need to add to db first
        // I want to check/validate request, before adding to database, therefore, I generate new id
        // TODO: is it ok for this?
        id:UUID.v1(), // identify id for import request, uquide
        state:IMPORT_STATE_IDLE, // state of importing process
        result:ERR.ErrFailed, // result - error code of importing processing
        resultMsg:null, // result message - in string, of importing processing
        lastUpdated:0, // last updated time, in ms
        title:title, // title of import request, for hint/tracking/informative
        projects:projects, // list of project ids (db id) to be assigned to vuls
        modules:modules, // list of module, to be assigned to vuls
        added:0, // the number of items added
        skipped:0, // the number of items skipped
        // req is cloned to new process/worker, nodejs not support to clone function call
        // toString:function(){
        //     return `${this.fpath}, ${this.id}, ${this.result}, ${this.state}`;
        // }
    }

    log.i(`Build import request ${importReqString(item)}`);
    return item;
}

// req is cloned to new process/worker, nodejs not support to clone function call
// therefore, we need to make other function to get string format of req, instead of adding "toString" property to import request object
function importReqString(req){
    return `${req.id}, ${req.source}, ${req.path}, ${req.result}, ${req.state}, ${req.resultMsg}`;
}

/**
 * Get import request from cache
 * @param {*} reqId Import request id
 * @returns Import request, null if not exist
 */
function getImportReq(reqId){
    var req = null;
    if (requestList.hasOwnProperty(reqId)){
        req = requestList[reqId];
    }
    // TODO: auto clean up cache?
    return req;
}

/**
 * Add import request to cache
 * @param {*} req import request
 */
function add2ReqList(req){
    if (DEBUG) if (DEBUG) log.d(`add2ReqList ${req.id}`);
    req.lastUpdated = COMMON.currentTimeMs();

    
    requestList[req.id] = req;
    log.dumpDict(requestList, "Import Req list", ' ' , importReqString);

    // TODO: auto clean up old req????
}

/**
 * Update import request in cache
 * @param {*} req 
 */
function updateReqList(req){
    if (DEBUG) log.d(`updateReqList ${req.id}`);
    // TODO: validate info?
    requestList[req.id] = req;
    // TODO: auto clean up old req????
}

/**
 * Update status of importing
 * @param {*} id Import Request id
 * @param {*} state status of importing
 */
function updateReqState(id, state){
    // TODO: validate input id/state?
    if (requestList.hasOwnProperty(id)){
        requestList[id].state = state;

    }
}

/**
 * Clean up import request from cache
 * @param {*} req 
 */
function clearReq(req){
    // TODO: valiate input?
    if (DEBUG) log.d(`clearReq ${req.id}`);
    if (requestList.hasOwnProperty(req.id)){
        delete requestList[req.id];

    }
    log.dumpDict(requestList, "Import Req list", ' ' , importReqString);
}

/**
 * Request to clean up import request cache
 * @param {*} req 
 */
function reqClearReqList(req){
    if (DEBUG) log.d(`reqClearReqList ${req.id}`);
    // check after specific time
    setTimeout(function() {
        clearReq(req);
     }, 60000);
}

/**
 * Import Vul from file
 * @param {*} fpath 
 * @param {*} source 
 * @param {*} title 
 * @param {*} projects project ids list
 * @param {*} modules module list, in format name[:version]
 * @param {*} callback 
 * @returns 
 */
function importCve(fpath, source, title = "", projects = [], modules = [], callback = null){
    log.i(`Import CVE file ${fpath}`);

    // TODO: validate input


    var req = buildImportReq(fpath, source, title, projects, modules);

    // check if import source is supported
    if (!IMPORTER_FILE_LIST.hasOwnProperty(source)){
        log.e(`Unknow source '${source}' to import`)
        req.resultMsg = `Unsupport source '${source}'`;
        req.state = IMPORT_STATE_ERROR;
        req.result = ERR.ErrInvalid;
        callback(req);
        return req;
    }

    var importerFile = `./${IMPORT_FILE_ROOT}/${IMPORTER_FILE_LIST[source]}`;

    if (DEBUG) log.d(`importerFile ${importerFile}`);

    // check if file exist
    if (!FS.existsSync(importerFile))
    {
        log.e(`'${importerFile} not exist`);
        req.resultMsg = `Not found importer file of source '${source}'`;
        req.state = IMPORT_STATE_ERROR;
        req.result = ERR.ErrNotFound;
        callback(req);
        return req;
    }

    req.workingDir = PATH.join(CONFIG.getImportLocation(), req.id);
    
    if (!FS.existsSync(req.workingDir)){
        log.i(`'${req.workingDir} not exist, create one`);
        FS.mkdirSync(req.workingDir, { recursive: true });
    }


    var parsedSourceFile = PATH.parse(fpath);
    var fnameNoExt = parsedSourceFile.name;
    var fext = parsedSourceFile.ext;
    var importFname = `source${fext}`;
    var newSourceFile = PATH.join(req.workingDir, importFname);

    if (COMMON.isEmpty(title)){
        title = fnameNoExt;
        req.title = title;
    }

    add2ReqList(req);
    updateReqState(req.id, IMPORT_STATE_PREPARE);

    
    if (DEBUG) log.d(`Move file from ${fpath} to ${newSourceFile}`);
    FS.rename(fpath, newSourceFile, err => {
        if (DEBUG) log.d(`Moved file callback`);
        if (err)
        {
            log.e(`Move ${fpath} to new location ${newSourceFile} Failed: ${err}`);
            req.state = IMPORT_STATE_ERROR;
            req.result = ERR.ErrFailed;
            callback(req);
        }
        else{
           
            req.path = newSourceFile;
            updateReqList(req);
            if (DEBUG) log.d(`Add import id ${req.id} to db`);

            // add import request info to db
            CVE_IMPORT_DB.add(title, req.id, req.workingDir, req.source, req.state)
                .then(function(importItem){
                    log.i(`Add import item ${req.id} ok`);
                    updateReqState(req.id, IMPORT_STATE_PARSE);

                    // fork worker to run importing processing in separate processes
                    var promise =  new Promise(function(resolve, reject){
                        const worker = new Worker(importerFile, {workerData:{
                            req
                        }});
                        worker.on("message", resolve);
                        worker.on("error", reject);
                        worker.on("exit", (code)=>log.e(`Import finished with Exit code: ${code}`));
                    });

                    promise // handling resolve shall be separated into multi then()
                        .then((req) => {
                            // Import finished, update request cache
                            if (DEBUG) log.d(`Import ${req.id} done`);
                            req.lastUpdated = COMMON.currentTimeMs();
                            req.state = IMPORT_STATE_DONE;
                            log.e(`Result of import ${importReqString(req)}`);
                            updateReqList(req);

                            return req;
                            })
                        .then((req) => {
                            // start update import request to db
                            if (DEBUG) log.d(`Update import ${req.id} to db`);
                            importItem.importStatus = req.state;
                            importItem.importResult = req.result;
                            importItem.importResuleMsg = req.resultMsg;
                            importItem.added = req.added;
                            importItem.skipped = req.skipped;
                            return CVE_IMPORT_DB.updateItem(importItem);
                        })
                        .then((importItem)=>{
                            // update ok, check to cleanup/callback to caller
                            if (DEBUG) log.d(`Update import ${importItem.importId} to db ok`);
                            callback(req);
                            reqClearReqList(req);
                        })
                        .catch(error => {
                            log.e(error);
                            req.lastUpdated = COMMON.currentTimeMs();
                            req.state = IMPORT_STATE_ERROR;
                            req.result = ERR.ErrFailed;

                            importItem.importStatus = req.state;
                            importItem.importResult = req.result;
                            importItem.importResuleMsg = req.resultMsg;
                            CVE_IMPORT_DB.updateItem(importItem);

                            updateReqList(req);
                            callback(req);
                            reqClearReqList(req);
                        });
                })
                .catch(err => {
                    log.e(`Added import req ${req.id} to db failed ${err}`);
                    req.state = IMPORT_STATE_ERROR;
                    req.result = ERR.ErrFailed;
                    callback(req);
                })
                ;
            ;
            
        }
        
    });

    
    return req;
}

/**
 * Get path of summarization file of import request
 * @param {*} req 
 * @returns 
 */
function getImportSummarizePath(req){
    var path =  PATH.join(req.workingDir, IMPORT_SUMMARIZE_FNAME);
    if (DEBUG) log.d(`getImportSummarizePath ${path}`);
    return path;
}
function getImportVulInfoPath(req){
    return  PATH.join(req.workingDir, IMPORT_VUL_INFO_FNAME);
}

/**
 * Build import summary
 * @param {*} importId 
 * @param {*} title 
 * @param {*} workDir 
 * @param {*} total 
 * @param {*} added 
 * @param {*} skipped 
 * @param {*} result 
 * @param {*} msg 
 * @param {*} startTime 
 * @param {*} endTime 
 * @returns 
 */
function buildSummarizeInfo(importId = null, title = null, workDir=null, total = 0, added=0, skipped=0, result=ERR.ErrFailed,  msg=null, startTime=0, endTime=0){
    return {
        title:title,
        importId:importId,
        workDir:workDir,
        total:total,
        added:added,
        skipped:skipped,
        startTime:startTime,
        endTime:endTime,
        result:result,
        msg:msg
    }
}

/**
 * Read import summary
 * @param {*} req Import request
 * @param {*} callback callback back (error code, data)
 */
function readImportSummarize(req, callback){
    if (DEBUG) log.d(`readImportSummarize ${importReqString(req)}`);
    var fpath = getImportSummarizePath(req);
    if (DEBUG) log.d(`read from fpath ${fpath}`);
    if (FS.existsSync(fpath)){
        FS.readFile(fpath, {encoding: 'utf-8'}, function(err,data){
            if (DEBUG) log.d(`Read file ${fpath} callback`);
            if (!err) {
                callback(ERR.ErrNone, data);
            } else {
                log.e(`read sum info to file  ${fpath} FAILED, ${err}`);
                callback(ERR.ErrFailed, err);
            }
        });
    }
    else{
        log.e(`File ${fpath} not exist to read`);
        callback(ERR.ErrNotExist, null);
    }
    
}

/**
 * Write summarize info of importing to file
 * @param {*} req Import request
 * @param {*} sum summarize info
 * @param {*} callback callback when finish  callback(error code, data). Data is request if success, Err object if failed
 */
function writeImportSummarize(req, sum, callback){
    if (DEBUG) log.d(`writeImportSummarize ${importReqString(req)}`);
    var fpath = getImportSummarizePath(req);
    if (DEBUG) log.d(`write to fpath ${fpath}`);
    var str = '';
    // FIXME: fix me please
    str += `- Import Id: ${sum.importId};\n`;
    str += `- Title: ${sum.title};\n`;
    str += `- workDir: ${sum.workDir};\n`;
    str += `- total: ${sum.total};\n`;
    str += `- added: ${sum.added};\n`;
    str += `- skipped: ${sum.skipped};\n`;
    str += `- startTime: ${(new Date(sum.startTime).toISOString())};\n`;
    str += `- endTime: ${(new Date(sum.endTime).toISOString())};\n`;
    str += `- result: ${sum.result};\n`;
    str += `- msg: ${sum.msg};\n`;
    FS.writeFile(fpath, str, function(err){
        if (!err){
            if (DEBUG) log.d(`write sum info to file  ${fpath} OK`);
            callback(ERR.ErrNone, req);
        }
        else{
            log.e(`write sum info to file  ${fpath} FAILED, ${err}`);
            callback(ERR.ErrFailed, err);
        }
    });
}

/**
 * Build import info in detail
 * @param {*} vulId Vul number
 * @param {*} cveId CVE number
 * @param {*} id vul id (db id)
 * @param {*} status status of importing
 * @param {*} result Error code of importing
 * @param {*} msg Error message of importing
 * @returns 
 */
function buildImportVulInfo(vulId = null, cveId = null, id=null, status=IMPORT_VUL_STATUS_UNKNOWN, result=ERR.ErrFailed, msg=null){
    return{
        vulId:vulId,
        cveId:cveId,
        id:id,
        status:status,
        msg:msg,
        result:result,
        createdTime:0,
    }
}
/**
 * Append log of importing vul/CVE
 * @param {*} req 
 * @param {*} vulInfo : map with key, value, build via buildImportVulInfo()
 * @param {*} callback callback (import request, error code, data)
 */
function appendLogVulImportInfo(req, vulInfo, callback){
    if (DEBUG) log.d(`appendLogVulImportInfo ${importReqString(req)}`);
    var fpath = getImportVulInfoPath(req);
    if (DEBUG) log.d(`append to fpath ${fpath}`);
    if (!FS.existsSync(fpath)){
        var strhead = "# vul_number, cve_number, db id, created time, status, result code, result message\n";
        FS.writeFileSync(fpath, strhead);
    }
    
    var str = `${vulInfo.vulId},${vulInfo.cveId},${vulInfo.id},${(new Date(vulInfo.createdTime).toISOString())},${vulInfo.status},${vulInfo.result},${vulInfo.msg}\n`;
    FS.appendFile(fpath, str, function(err){
        if (!err){
            if (DEBUG) log.d(`Append info to file  ${fpath} OK`);
            if (callback) callback(req, ERR.ErrNone, vulInfo);
        }
        else{
            log.e(`Append info to file  ${fpath} FAILED, ${err}`);
            if (callback) callback(req, ERR.ErrFailed, err);
        }
    });

}


/**
 * Get import infor of an import request id
 * @param {*} importId 
 * @param {*} callback 
 * @returns 
 */
function getImportInfo(importId, callback){
    return CVE_IMPORT_DB.get(importId)
        .then((item) => {
            callback(ERR.ErrNone, item);
        })
        .catch((err) => {
            callback(ERR.ErrFailed, err);
        })
    ;
}

/**
 * Get list of import requests, return resule via callback
 * @param {*} callback 
 */
function getList(callback){
    if (DEBUG) log.d("Get list of import")
    CVE_IMPORT_DB.getAll()
        .then(items => {
            if (DEBUG) log.d("Get list of import ok")
            callback(ERR.ErrNone, items);
        })
        .catch(err => {
            if (DEBUG) log.d(`Get list of import failed ${err}`);
            callback(ERR.ErrFailed, err);
        })
        ;
}


/**
 * Get list of import request, return via Promise
 * @returns 
 */
function getList2(){
    if (DEBUG) log.d("Get list 2 of import")
    return CVE_IMPORT_DB.getAll();
}


////////////////////////////////////////////////////////////////////
// MODULE EXPORT
////////////////////////////////////////////////////////////////////
exports.importCve = importCve;
exports.buildImportReq = buildImportReq;
exports.getImportReq = getImportReq;
exports.getImportInfo = getImportInfo;
exports.importReqString = importReqString;
exports.buildSummarizeInfo = buildSummarizeInfo;

exports.writeImportSummarize = writeImportSummarize;
exports.readImportSummarize = readImportSummarize;
exports.buildImportVulInfo = buildImportVulInfo;
exports.appendLogVulImportInfo = appendLogVulImportInfo;


exports.getList = getList;
exports.getList2 = getList2;


exports.IMPORT_STATE_DONE = IMPORT_STATE_DONE;
exports.IMPORT_STATE_PREPARE = IMPORT_STATE_PREPARE;
exports.IMPORT_STATE_ERROR = IMPORT_STATE_ERROR;

exports.IMPORT_VUL_STATUS_DUP = IMPORT_VUL_STATUS_DUP;
exports.IMPORT_VUL_STATUS_ADDED = IMPORT_VUL_STATUS_ADDED;
exports.IMPORT_VUL_STATUS_ERR = IMPORT_VUL_STATUS_ERR;


exports.IMPORT_NIST = IMPORT_NIST;