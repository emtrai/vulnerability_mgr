/**
 * Copyright (C) 2022 Anh Huy Ngo - All Rights Reserved
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * 
 * Author: Anh Ngo
 * Created Date: 
 */
////////////////////////////////////////////////////////////////////
// MODULE LOADING
////////////////////////////////////////////////////////////////////

var ERR = require("../../errno");
var COMMON = require("../../common")
const fs = require("fs");
var log = require("../../log").build("nist");
var CVEITEM = require("../../model/cve/cve_item");
var CVE = require("../../model/cve/cve_db");

var DB = require('../../db/db');
var CVE_CTRL = require("../cve_ctrl");

const {
    isMainThread, parentPort, workerData
  } = require('worker_threads');



////////////////////////////////////////////////////////////////////
// GLOBAL VARIABLES
////////////////////////////////////////////////////////////////////


const JSON_CVE_ITEM = "CVE_Items";
const JSON_CVE = "cve";
const JSON_CVE_DATA_META = "CVE_data_meta";
const JSON_ID = "ID";
const JSON_DESC = "description";
const JSON_DESC_DATA = "description_data";
const JSON_LANG = "lang";
const JSON_VAL = "value";
const JSON_REF = "references";
const JSON_REF_DATA = "reference_data";
const JSON_URL = "url";
const JSON_TAGS = "tags";
const JSON_IMPACT = "impact";
const JSON_METRICV3 = "baseMetricV3";
const JSON_CVSSV3 = "cvssV3";
const JSON_PUBLISH_DATE = "publishedDate";
const JSON_LAST_MODIFIED_DATE = "lastModifiedDate";
const JSON_EXPLOIT_SCORE = "exploitabilityScore";
const JSON_IMPACT_SCORE = "impactScore";
const JSON_VECTOR = "vectorString";
const JSON_VECTOR_ATTACK = "attackVector";
const JSON_BASE_SCORE = "baseScore";
const JSON_BASE_SERVERITY = "baseSeverity";
// const JSON_TAGS = "tags";

////////////////////////////////////////////////////////////////////
// FUNCTION
////////////////////////////////////////////////////////////////////

// callback is called when return of function is ErrPending
// onItemCallback(item)
// onFinishCallback(errorcode, numberOfItems)
 function parse(fpath, onItemCallback, onFinishCallback){
    log.i(`Parse nist ${fpath}`);
    log.d(fpath);
    var ret = ERR.ErrFailed;
    try{
        if (fs.existsSync(fpath)){
            fs.readFile(fpath, 'utf-8', function(err, data){
                if (err){
                    throw err; // TODO: correct this
                }
                var obj = JSON.parse(data); // TODO: large file handling
                if (obj != null){
                    if (obj.hasOwnProperty(JSON_CVE_ITEM)){
                        var jitems = obj[JSON_CVE_ITEM];
                        if (jitems != null){
                            var requests = jitems.map(function(jitem){

                                var item = CVEITEM.buildItem(CVEITEM.SOURCE_NIST);
                                if (jitem.hasOwnProperty(JSON_CVE)){
                                    var jcve = jitem[JSON_CVE];

                                    // CVE information, such as id
                                    if (jcve.hasOwnProperty(JSON_CVE_DATA_META)){
                                        var jcve_data_meta = jcve[JSON_CVE_DATA_META];
                                        if (jcve_data_meta.hasOwnProperty(JSON_ID)){
                                            var jid = jcve_data_meta[JSON_ID];
                                            log.d(`CVE ID ${jid}`);
                                            
                                            item.cve_id = jid;
                                            item.vul_id = jid;
                                            
                                        }
                                    }
                                    // TODO: no cve id?
                                    

                                    // reference
                                    if (jcve.hasOwnProperty(JSON_REF)){
                                        log.d(`>> ${item.cve_id} parse ref`);
                                        var jobj = jcve[JSON_REF];
                                        if (jobj.hasOwnProperty(JSON_REF_DATA)){
                                            var jitems = jobj[JSON_REF_DATA];
                                            if (jitems != null){
                                                jitems.forEach(function(jitem){
                                                    var url = "";
                                                    if (jitem.hasOwnProperty(JSON_URL)){
                                                        url = jitem[JSON_URL];
                                                    }
                                                    var tag = "";

                                                    if (jitem.hasOwnProperty(JSON_TAGS)){
                                                        tag = jitem[JSON_TAGS];
                                                    }
                                                    var urltag = `${url} [${tag}]`;
                                                    log.d(`${jid} url ${urltag}`);
                                                    item.ref.push(urltag);
                                                });
                                            }
                                            else{
                                                log.d(`${jid} not found data in ${JSON_REF_DATA}`);
                                            }
                                        }
                                        else{
                                            log.d(`${jid} not found ${JSON_REF_DATA}`);
                                        }
                                    }
                                    else{
                                        log.d(`${jid} not found ${JSON_REF}`);
                                    }

                                    // description
                                    if (jcve.hasOwnProperty(JSON_DESC)){
                                        log.d(`>> ${item.cve_id} parse ${JSON_DESC}`);
                                        var jobj = jcve[JSON_DESC];
                                        if (jobj.hasOwnProperty(JSON_DESC_DATA)){
                                            var jitems = jobj[JSON_DESC_DATA];
                                            if (jitems != null){
                                                jitems.forEach(function(jitem){
                                                    var lang = "";
                                                    if (jitem.hasOwnProperty(JSON_LANG)){
                                                        lang = jitem[JSON_LANG];
                                                    }
                                                    var desc = "";

                                                    if (jitem.hasOwnProperty(JSON_VAL)){
                                                        desc = jitem[JSON_VAL];
                                                    }
                                                    var tmpdesc = `[${lang}] ${desc}`;
                                                    log.d(`${jid}  desc ${tmpdesc} `);
                                                    item.desc.push(tmpdesc);
                                                });
                                            }
                                        }
                                    }


                                    // last publish date
                                    if (jitem.hasOwnProperty(JSON_PUBLISH_DATE)){
                                        log.d(`>> ${item.cve_id} parse ${JSON_PUBLISH_DATE}`);
                                        item.cve_publishedDate = jitem[JSON_PUBLISH_DATE];
                                    }

                                    // last modified date
                                    if (jitem.hasOwnProperty(JSON_LAST_MODIFIED_DATE)){
                                        log.d(`>> ${item.cve_id} parse ${JSON_LAST_MODIFIED_DATE}`);
                                        item.cve_lastModifiedDate = jitem[JSON_LAST_MODIFIED_DATE];
                                    }

                                    item.added_date = COMMON.currentTimeMs();
                                    item.last_modified_date = COMMON.currentTimeMs();
                                    // impact
                                    if (jitem.hasOwnProperty(JSON_IMPACT)){
                                        log.d(`>> ${item.cve_id} parse ${JSON_IMPACT}`);
                                        var jobj = jitem[JSON_IMPACT];
                                        item.impact = JSON.stringify(jobj);

                                        if (jobj.hasOwnProperty(JSON_METRICV3)){
                                            log.d(`>> ${item.cve_id} parse ${JSON_METRICV3}`);
                                            var jmetric = jobj[JSON_METRICV3];
                                            if (jmetric.hasOwnProperty(JSON_CVSSV3)){
                                                log.d(`>> ${item.cve_id} parse ${JSON_CVSSV3}`);

                                                var jcvss = jmetric[JSON_CVSSV3];
                                                if (jcvss.hasOwnProperty(JSON_VECTOR)){
                                                    log.d(`>> ${item.cve_id} parse ${JSON_VECTOR}`);
                                                    item.vectorString = jcvss[JSON_VECTOR];
                                                }
                                                if (jcvss.hasOwnProperty(JSON_VECTOR_ATTACK)){
                                                    log.d(`>> ${item.cve_id} parse ${JSON_VECTOR_ATTACK}`);
                                                    item.vectorAttack = jcvss[JSON_VECTOR_ATTACK];
                                                }
                                                if (jcvss.hasOwnProperty(JSON_BASE_SCORE)){
                                                    log.d(`>> ${item.cve_id} parse ${JSON_BASE_SCORE}`);
                                                    item.baseScore = jcvss[JSON_BASE_SCORE];
                                                }
                                                if (jcvss.hasOwnProperty(JSON_BASE_SERVERITY)){
                                                    log.d(`>> ${item.cve_id} parse ${JSON_BASE_SERVERITY}`);
                                                    item.severity = jcvss[JSON_BASE_SERVERITY];
                                                }
                                            }
                                            if (jmetric.hasOwnProperty(JSON_EXPLOIT_SCORE)){
                                                log.d(`>> ${item.cve_id} parse ${JSON_EXPLOIT_SCORE}`);
                                                item.exploitabilityScore = jmetric[JSON_EXPLOIT_SCORE];
                                            }
                                            if (jmetric.hasOwnProperty(JSON_IMPACT_SCORE)){
                                                log.d(`>> ${item.cve_id} parse ${JSON_IMPACT_SCORE}`);
                                                item.impactScore = jmetric[JSON_IMPACT_SCORE];
                                            }
                                            
                                        
                                        }
                                        // TODO: baseMetricV2
                                    }
                                }
                                CVEITEM.analyzeItem(item);
                                // desc = item.getDesc()
                                // item.tag = CVEITEM.getTagList(desc);
                                // item.module = CVEITEM.getModuleList(desc);
                                // CVE.add(item);
                                log.d(`Add cve ${item.vul_id} to db`);
                                return CVE_CTRL.addCVE(item);
                                // CVE_CTRL.addCVE(item).then(item => {
                                //     if (onItemCallback != null)
                                //     {
                                //         log.d("call item callback");
                                //         onItemCallback(jid);
                                //     }
                                // });
                                
                            });


                            Promise.all(requests).then(()=>{
                                if (onFinishCallback != null) {
                                    log.d("call finish callback");
                                    onFinishCallback(ERR.ErrNone);
                                }
                            })
                        }
                    }
                }
                // if (onFinishCallback != null) {
                //     log.d("call finish callback");
                //     onFinishCallback(ERR.ErrNone);
                // }
                // Promise.all(requests).then(()=>{
                //     if (onFinishCallback != null) {
                //         log.d("call finish callback");
                //         onFinishCallback(ERR.ErrNone);
                //     }
                // })
            });
            ret = ERR.ErrPending;
        }
        else{
            ret = ERR.ErrNotExist;
        }
    }
    catch (err){
        log.i(err);
        ret = ERR.ErrException;
    }

    return ret;

}

////////////////////////////////////////////////////////////////////
// MODULE EXPORT
////////////////////////////////////////////////////////////////////

module.exports.parse = parse;

 

if (!isMainThread){
    var ret = DB.connectdbsync(null);
    log.d("in worker thread, start parsing");
    var req = workerData.req;
    var ret = parse(req.path, null, function(code){
        log.d("on finish callback");
        parentPort.postMessage(code);
    });
    if (ret !== ERR.ErrPending)
    {
        log.i(`Parse done, result ${ret}`);
        parentPort.postMessage(ret);
    }
}
// parentPort.on("message", (limit) => {
//     const result = parse(limit);    
//     parentPort.postMessage(result);
//    });