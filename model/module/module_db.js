/**
 * Copyright (C) 2022 Anh Huy Ngo - All Rights Reserved
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * 
 * Author: Anh Ngo
 * Created Date: 
 */
////////////////////////////////////////////////////////////////////
// MODULE LOADING
////////////////////////////////////////////////////////////////////


const { UUID } = require('bson');
var MONGO = require('mongoose')

var DB = require('../../db/db');
var COMMON = require('../../common');
var ERR = require("../../errno");
var CRYPTO = require("../../crypto");


////////////////////////////////////////////////////////////////////
// GLOBAL VARIABLES
////////////////////////////////////////////////////////////////////

const SCHEMA_NAME = "module";

var log = require("../../log").build("moduledb");

MONGO.pluralize(null);
// module like linux kernel, openssl, android, etc.
var module_schema = new MONGO.Schema({
    nameid:String,
    name:String,
    versions:[String], // list of version name
    tags:[String],
    keywords:[String],
    desc:String,
    history:String,// history
    created_date:Number, // date of creation
    modified_date:Number, // last modified time
    status:Number, // delete, active, etc.
});

var MODULE = MONGO.model(SCHEMA_NAME, module_schema);


////////////////////////////////////////////////////////////////////
// FUNCTION
////////////////////////////////////////////////////////////////////

function buildItem(){
    log.d("Build item");
    return {
        id:null,
        nameid:null,
        name:null,
        desc:null,
        versions:[],
        tags:[],
        keywords:[],
        toString:function(){
            return `${this.id}, ${this.name}`;
        }
    };
}

function db2Item(db, item = null){    
    log.d("db2Item");
    if (!item){
        
        item = buildItem();
    }
    // TODO: validate info

    item.id = db._id;
    item.name = db.name;
    item.nameid = db.nameid;
    item.desc = db.desc;
    db.tags.forEach(tag => item.tags.push(tag));
    db.versions.forEach(ver => item.versions.push(ver));
    if (!COMMON.isEmpty(db.keywords))
        db.keywords.forEach(element => item.keywords.push(element));
    
    return item;
}




function getList(){
    log.d("getList");
    return new Promise((resolve, reject) => {
        DB.connectdbsync(null);
        MODULE.find({})
            .sort('name')
            .exec(function(err, modules){
                var items = [];
                if (!COMMON.isEmpty(modules)){
                    log.i("Found items");
                    modules.forEach(function(element){
                        log.i(`found module ${element.name}`);
                        var item = db2Item(element);
                        items.push(item);
                        
                    });
                }
                else{
                    log.i("not found any cve");
                }
                
                resolve(items);
        });
    })
    
}


function getModule(name){
    log.d("getList");
    return new Promise((resolve, reject) => {
        DB.connectdbsync(null);
        var nameid = getNameId(item.name);
        MODULE.findOne({nameid:nameid})
            .exec(function(err, module){
                if (module){
                    log.i(`Found item ${module.name}`);
                    var item = db2Item(element);
                    resolve(module);
                }
                else{
                    log.i("not found any cve");
                    reject(err);
                }
        });
    })
    
}

function getNameId(name){
    log.d(`getNameId ${name}`);
    var nameid = COMMON.str2strId(name);
    log.d(`nameid ${nameid}`);
    return nameid;
}

function add(item){
    log.i(`add module ${item.name}`);
    return new Promise((resolve, reject) => {
        var nameid = getNameId(item.name);
        DB.connectdbsync(null);
        MODULE.findOne({nameid:nameid}, function(err, module){
            log.d(`findOne callback ${item.name}`);
            var ret = ERR.ErrFailed;
            var ret_msg = "Failed";
            
            if (err){
                reject(COMMON.buildError(ret_msg, ret, item, err));
                // reject(err);
                return;
            }
            // TODO: add tags
            if (module){ // existed, update other information like version if any
                item.id = module._id;
                log.i(`module ${item.name} already exist, id ${item.id}, check version ${item.versions}`);
                log.d(module.versions);
                if (!COMMON.isEmpty(item.versions)){ // update version
                    if (COMMON.isEmpty(module.versions)){
                        log.d("Not exist version yet, init one");
                        
                        module.versions = [];
                        item.versions.forEach(element => {
                            module.versions.push(element.toLowerCase());
                        });
                        ret = ERR.ErrNone;
                        ret_msg = "Add new version OK";
                    }
                    else{
                        item.versions.forEach(version => {
                            version = version.toLowerCase();
                            if (!module.versions.includes(version)){
                                log.d(`Version ${version} not exist, add new one and update db`);
                                module.versions.push(version);
                                ret = ERR.ErrNone;
                                ret_msg = "Add new version OK";
                            }
                            else{
                                log.e(`Version ${item.versions}  existed`);
                                ret = ERR.ErrExist;
                                ret_msg = `Version ${item.versions} already existed`;
                            }
                        });
                    }
                }
                else{
                    log.e(`Empty version info`);
                    ret = ERR.ErrExist;
                    ret_msg = "Empty version info";
                }
                if (ret == ERR.ErrNone)
                {
                    module.last_modified_date = COMMON.currentTimeMs();
                    module.save((err, module2)=>{
                        if (err){
                            ret_msg = `Update module ${item.name} failed ${err}`;
                            log.i(ret_msg);
                            // reject(err);
                            reject(COMMON.buildError(ret_msg, ERR.ErrFailed, item, err));
                        }
                        else{
                            log.i(`Update module ${item.name} OK`);
                            resolve(db2Item(module2));
                        }                        
                    });
                    
                    // TODO: handle error case
                }
                else{
                    // reject(new Error(ret_msg));
                    reject(COMMON.buildError(ret_msg, ret, item));
                }
            }
            else{
                            
                var moduledb = new MODULE();
                moduledb.nameid = nameid;
                moduledb.name = item.name;
                moduledb.desc = item.desc;
    
                log.i(`Module ${item.name} not exist, create new`);
                moduledb.versions = [];
                if (!COMMON.isEmpty(item.versions)){
                    item.versions.forEach(element => {
                        moduledb.versions.push(element.toLowerCase());
                    });
                }
                else{
                    moduledb.versions = [];
                }

                moduledb.tags = [];
                if (!COMMON.isEmpty(item.tags)){
                    item.tags.forEach(element => {
                        moduledb.tags.push(element.toLowerCase());
                    });
                }
                else{
                    moduledb.tags = [];
                }
    
                
                moduledb.keywords = [];
                if (!COMMON.isEmpty(item.keywords)){
                    item.keywords.forEach(element => {
                        moduledb.keywords.push(element.toLowerCase());
                    });
                }
                else{
                    moduledb.keywords = [];
                }
    

                moduledb.added_date = COMMON.currentTimeMs();
                moduledb.last_modified_date = COMMON.currentTimeMs();
                // TODO: update history?
                // TODO: add tags
                ret = ERR.ErrNone;
                ret_msg = "Add new module OK";
                moduledb.save((err, module2)=>{
                    if (err){
                        ret = ERR.ErrFailed;
                        ret_msg = `Add module ${item.name} failed ${err}`;
                        log.i(ret_msg);
                        // reject(err);
                        reject(COMMON.buildError(ret_msg, ret, item, err));
                    }
                    else{
                        log.i(`Update module ${item.name} OK`);
                        resolve(db2Item(module2));
                    }
                    
                });
                // TODO: handle error case
            }
            
            // if (callback)
            //     callback(ret, this.name, ret_msg);
        });
        // }.bind({nameid:Object.assign({}, nameid), name:Object.assign({}, name), versions:Object.assign({}, versions)}));
    });
    
}

function updateModule(name, newname, version, callback){
    log.i(`updateModule module ${name}, ${newname}, ${version}`);
    var nameid = COMMON.str2strId(name);
    var newnameid = null;
    var cond = [{ 'nameid': nameid }];
    if (!COMMON.isStrEmpty(newname))
        newnameid = COMMON.str2strId(newname);
        cond.push({ 'nameid': newnameid });
    log.d(`cond ${cond}`);
    MODULE.findOne({$or: cond}, async function(err, module){
        log.d(`updateModule findOne callback ${this.name}`);
        if (module){
            log.i(`module ${this.name} already exist, check version ${this.version}`);
            log.d(module.versions);
            var ret = ERR.ErrFailed;
            var ret_msg = "Failed";
            if (this.newnameid != null){
                module.name = this.newName;
                module.nameid = this.newnameid;
            }
            
            if (!COMMON.isStrEmpty(this.version)){
                if (COMMON.isEmpty(module.versions)){
                    log.d("Not exist version yet, init one");
                    module.versions = [this.version.toLowerCase()];
                    ret = ERR.ErrNone;
                }
                else{
                    if (!module.versions.includes(this.version)){
                        log.d(`Version ${this.version} not exist, add new one and update db`);
                        module.versions.push(this.version.toLowerCase());
                        ret = ERR.ErrNone;
                    }
                    else{
                        log.e(`Version ${this.version}  existed`);
                        ret = ERR.ErrExist;
                    }
                }
            }
            else{
                log.e(`Empty version info`);
                ret = ERR.ErrInvalid;
            }
            if (ret == ERR.ErrNone)
            {
                await module.save();
                log.i(`Added module ${this.name} OK`);
                // TODO: handle error case
            }
        }
        else{
            ret = ERR.ErrNotFound;
            ret_msg = `Module ${this.name} Not FOUND`;
            log.e(ret_msg); 
        }
        if (callback)
            callback(ret, this.name, ret_msg);
    }.bind({name:Object.assign({}, name), newName:Object.assign({}, newName), newnameid:Object.assign({}, newnameid), version:Object.assign({}, version)}));
    return ERR.ErrNone;
}

////////////////////////////////////////////////////////////////////
// MODULE EXPORT
////////////////////////////////////////////////////////////////////

module.exports.updateModule = updateModule
module.exports.getList = getList
module.exports.add = add
exports.buildItem = buildItem;
exports.getModule = getModule;
exports.SCHEMA_NAME = SCHEMA_NAME;