////////////////////////////////////////////////////////////////////
// MODULE LOADING
////////////////////////////////////////////////////////////////////

var ERR = require("../../errno");
var COMMON = require("../../common");
var log = require("../../log").build("module_cve");

var DB = require('../../db/db');
var CONST = require('../../const');
const { UUID } = require('bson');
var MONGOOSE = require('mongoose')
var MODULE = require('./module_db')
var CVE = require('../cve/cve_db')
////////////////////////////////////////////////////////////////////
// GLOBAL VARIABLES
////////////////////////////////////////////////////////////////////
const SCHEMA_NAME = "module_cve";

MONGOOSE.pluralize(null);

// cve include multiple domain
var projectSchema = new MONGOOSE.Schema({
    vulId:MONGOOSE.ObjectId, // 
    moduleId:MONGOOSE.ObjectId, // 
    moduleVersions:[String], // version that vuln/CVE exists
    fixModuleVersion:[String], // version that vuln/CVE was fixed
    addedDate:Number,
    lastModifiedDate:Number,
    status:{type:Number, default:DB.STATUS_NEW}, // status: active, on-hold, etc.
});

var MODEL = MONGOOSE.model(SCHEMA_NAME, projectSchema);

////////////////////////////////////////////////////////////////////
// FUNCTION
////////////////////////////////////////////////////////////////////
function buildItem(){
    log.d("Build cve-module item");
    return {
        id:null,
        vulId:null,
        moduleId:null,
        moduleVersions:[],
        moduleName:null,
        status:DB.STATUS_NEW,
        toString:function(){
            return `${this.id};${this.vulId};${this.moduleId};${this.getVersions()}`;
        },
        getVersions:function(){
            var versions = "";
            this.moduleVersions.forEach(element => versions += element + ",");
            return versions;
        }
    };
}

function db2Item(db, item = null){    
    if (!item){
        item = buildItem();
    }
    // TODO: validate info
    log.d(`db2Item, id ${db._id}, vulId ${db.vulId}, moduleId ${db.moduleId}`)
    item.id = db._id;
    item.vulId = db.vulId;
    item.moduleId = db.moduleId;
    item.moduleName = db.moduleName;
    item.status = db.status;
    db.moduleVersions.forEach(element => item.moduleVersions.push(element));
    
    return item;
}


function add(vulId, moduleId, moduleVersions){
    log.i(`add mapping cve ${vulId}, module ${moduleId}, version ${moduleVersions}`);
    return new Promise((resolve, reject) => {
        DB.connectdbsync(null);
        MODEL.findOne({vulId:vulId, moduleId:moduleId}, function(err, itemdb){
            log.d(`findOne callback`);
            var ret = ERR.ErrFailed;
            var ret_msg = "Failed";
            if (err){
                log.e(`Find cve, module mapping failed ${err}`);
                reject(err);
                return;
            }
            // TODO: add tags
            if (itemdb){ // existed, update other information like version if any
                log.i(`mapping ${vulId} - ${moduleId},already exist, check version ${moduleVersions}`);
                log.d(itemdb.moduleVersions);
                if (!COMMON.isEmpty(moduleVersions)){ // update version
                    if (COMMON.isEmpty(itemdb.moduleVersions)){
                        log.d("Not exist version yet, init one");
                        
                        itemdb.moduleVersions = [];
                        moduleVersions.forEach(element => {
                            itemdb.moduleVersions.push(element.toLowerCase());
                        });
                        ret = ERR.ErrNone;
                        ret_msg = "Add new version OK";
                    }
                    else{
                        moduleVersions.forEach(version => {
                            version = version.toLowerCase();
                            if (!itemdb.moduleVersions.includes(version)){
                                log.d(`Version ${version} not exist, add new one and update db`);
                                itemdb.moduleVersions.push(version);
                                ret = ERR.ErrNone;
                                ret_msg = "Add new version OK";
                            }
                            else{
                                log.e(`Version ${version}  existed`);
                                ret = ERR.ErrExist;
                                ret_msg = `Version ${version} already existed`;
                            }
                        });
                    }
                }
                else{
                    log.i(`Empty version info`);
                    ret = ERR.ErrNone;
                    // ret_msg = "Empty version info";
                }
                if (ret == ERR.ErrNone)
                {
                    itemdb.lastModifiedDate = COMMON.currentTimeMs();
                    itemdb.save((err, module2)=>{
                        if (err){
                            log.i(`Update mapping failed failed ${err}`);
                            reject(err);
                        }
                        else{
                            log.i(`Update prj-module map OK`);
                            resolve(db2Item(module2));
                        }                        
                    });
                    
                    // TODO: handle error case
                }
                else if (ret == ERR.ErrExist){
                    log.i("Version existed, do nothing");
                    resolve(db2Item(itemdb));
                }
                else{
                    reject(new Error(ret_msg));
                }
            }
            else{
                            
                var itemdb = new MODEL();
                itemdb.vulId = vulId;
                itemdb.moduleId = moduleId;
    
                log.i(`Mapping not exist, create new`);
                itemdb.moduleVersions = [];
                if (!COMMON.isEmpty(moduleVersions)){
                    log.d("Add module version");
                    moduleVersions.forEach(element => {
                        log.d(`Add version ${element}`);
                        itemdb.moduleVersions.push(element.toLowerCase());
                    });
                }
                else{
                    log.d("No version to add");
                    itemdb.moduleVersions = [];
                }

                itemdb.addedDate = COMMON.currentTimeMs();
                itemdb.lastModifiedDate = COMMON.currentTimeMs();
                // TODO: update history?
                // TODO: add tags
                ret = ERR.ErrNone;
                ret_msg = "Add new module OK";
                itemdb.save((err, module2)=>{
                    if (err){
                        log.i(`Add cve-module map failed ${err}`);
                        reject(err);
                    }
                    else{
                        log.i(`Add cve-module map OK`);
                        resolve(db2Item(module2));
                    }
                    
                });
                // TODO: handle error case
            }
            
            // if (callback)
            //     callback(ret, this.name, ret_msg);
        });
        // }.bind({nameid:Object.assign({}, nameid), name:Object.assign({}, name), versions:Object.assign({}, versions)}));
    });
}

function getModuleListOfCVE(vulId){
    log.d(`getModuleListOfCVE ${vulId}`);
    return new Promise((resolve, reject) => {
        DB.connectdbsync(null);
        MODEL.aggregate([
            {
                $lookup: {
                    from:MODULE.SCHEMA_NAME, // collection name in db
                    localField: "moduleId",
                    foreignField: "_id",
                    as: "moduleinfo"
                },
            },
            {   $unwind:"$moduleinfo" },
            {
                $match:{
                    $and:[{"vulId" : vulId}]
                }
            },
            {   
                $project:{
                    _id : 1,
                    moduleId:1,
                    moduleVersions:1,
                    moduleName : "$moduleinfo.name",
                } 
            },
    
    ]).exec(function(err, modules) {

        log.d(`getModuleListOfCVE ${vulId} CALLBACK`);
            if (err){
                reject(COMMON.buildError(`Failed to get module list for cve ${vulId}`, ERR.ErrFailed, vulId));
            }
            else{
                // log.d(modules);
                var moduleList = [];
                log.dumpArray(modules, "Module");
                modules.forEach(module => {
                    // log.d(`${module.name}, ${module.moduleVersions}`);
                    // console.log(module);
                    moduleList.push(db2Item(module));
                })
                resolve(moduleList);
            }
        }); 
    });
}


function countCVE(moduleId){
    log.d(`countCVE ${moduleId}`);
    return new Promise((resolve, reject) => {

        var condition = [];
        if (Array.isArray(moduleId))
        {
            if (!COMMON.isEmpty(moduleId)){
                moduleId.forEach(element => {
                    condition.push({moduleId:element})
                })
            }
                
        }
        else{
            condition.push({moduleId:moduleId})
        }
        // MODEL.count({moduleId:moduleId}, function(err, count) {
        MODEL.count({ $or:condition}, function(err, count) {
            log.d(`countCVE callback ${moduleId}`);
            if (!err){
                log.d(`Count ${count}`);
                resolve(count);
            }
            else{
                var msg = `Count cve of module ${moduleId} failed. ${err}`;
                log.e(msg);
                reject(COMMON.buildError(msg, ERR.ErrFailed, moduleId, err));
            }
        });
    })

}


async function delAllModuleOfVul(vulId){
    return new Promise(async (resolve, reject) => {
        log.d(`delAllModuleOfVul ${vulId}`);
        DB.connectdbsync(null);
        // const result = await MODEL.deleteMany({vulId:vulId});
        // if (result.ok == 1){
        //     log.d(`Deleted ${result.deletedCount} for vul ${vulId}`);
        //     resolve(result.deletedCount);
        // }
        // else{
        //     log.e(`Delete mod of cve ${vulId} failed, result ${result.ok}`);
        //     reject(COMMON.buildError(`Delete mod of cve ${vulId} failed`, ERR.ErrFailed, vulId));
        // }
        MODEL.deleteMany({vulId:vulId}, function(err, result)
        {
            log.d(`delAllModuleOfVul deleteMany finish`);
            if (!err){
                log.raw(result, "result");
                log.d(`delAllModuleOfVul Deleted ${result.deletedCount} for vul ${vulId}`);
                resolve(result.deletedCount);
            }
            else{
                log.e(`delAllModuleOfVul Delete mod of cve ${vulId} failed, result ${err}`);
                reject(COMMON.buildError(`Delete mod of cve ${vulId} failed`, ERR.ErrFailed, vulId, err));
            }
            
        });
    });

}

async function delModOfVul(vulId, moduleId){
    return new Promise(async (resolve, reject) => {
        log.d(`delModOfVul ${vulId}, mod ${moduleId}`);
        DB.connectdbsync(null);
        // const result = await MODEL.deleteMany({vulId:vulId, moduleId:moduleId});
        // if (result.ok == 1){
        //     log.d(`delModOfVul Deleted ${result.deletedCount} for vul ${vulId}`);
        //     resolve(result.deletedCount);
        // }
        // else{
        //     log.e(`delModOfVul Delete mod of cve ${vulId} failed, result ${result.ok}`);
        //     reject(COMMON.buildError(`Delete mod of cve ${vulId} failed`, ERR.ErrFailed, vulId));
        // }
        MODEL.deleteMany({vulId:vulId, moduleId:moduleId}, function(err, result)
        {
            log.d(`delModOfVul deleteMany finish`);
            if (!err){
                log.raw(result, "result");
                log.d(`delModOfVul Deleted ${result.deletedCount} for vul ${vulId}`);
                resolve(result.deletedCount);
            }
            else{
                log.e(`delModOfVul Delete mod of cve ${vulId} failed, result ${err}`);
                reject(COMMON.buildError(`Delete mod of cve ${vulId} failed`, ERR.ErrFailed, vulId, err));
            }
            
        });
    });

}


function delModOfVulWithModuleName(vulId, name){
    return new Promise(async (resolve, reject) => {
        log.d(`delModOfVulWithModuleName ${vulId}, mod ${name}`);
        DB.connectdbsync(null);
        MODULE.getModule(name).then(module=>{
            log.d(`Get module name ${name} callback`);
            if (module)
            {
                MODEL.deleteMany({vulId:vulId, moduleId:module.id}, function(err, result)
                {
                    log.d(`delModOfVul deleteMany finish`);
                    if (!err){
                        log.raw(result, "result");
                        log.d(`delModOfVul Deleted ${result.deletedCount} for vul ${vulId}`);
                        resolve(result.deletedCount);
                    }
                    else{
                        log.e(`delModOfVul Delete mod of cve ${vulId} failed, result ${err}`);
                        reject(COMMON.buildError(`Delete mod of cve ${vulId} failed`, ERR.ErrFailed, vulId, err));
                    }
                    
                });
            }
            else{
                log.e(`delModOfVulWithModuleName module name not found ${name}`);
                reject(COMMON.buildError(`Get module info failed`, ERR.ErrFailed, name));
            }
            
        })
        .catch(err => {
            log.e(`delModOfVulWithModuleNameGet module info failed ${err}`);
            reject(COMMON.buildError(`Get module info failed`, ERR.ErrFailed, name, err));
        })
        ;
        
    });

}

////////////////////////////////////////////////////////////////////
// MODULE EXPORT
////////////////////////////////////////////////////////////////////
// module.exports = cve;
module.exports.add = add;
module.exports.getModuleListOfCVE = getModuleListOfCVE;
module.exports.SCHEMA_NAME = SCHEMA_NAME;
module.exports.countCVE = countCVE;
module.exports.delModOfVul = delModOfVul;
module.exports.delAllModuleOfVul = delAllModuleOfVul;
module.exports.delModOfVulWithModuleName = delModOfVulWithModuleName;