
/**
 * Copyright (C) 2022 Anh Huy Ngo - All Rights Reserved
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * 
 * Author: Anh Ngo
 * Created Date: 
 */
////////////////////////////////////////////////////////////////////
// MODULE LOADING
////////////////////////////////////////////////////////////////////

var ERR = require("../../errno");
var log = require("../../log").build("cve_item");

var COMMON = require('../../common');
var TAG_CTRL = require('../../controller/tags_ctrl');
const { DEBUG } = require("../../config");

////////////////////////////////////////////////////////////////////
// GLOBAL VARIABLES
////////////////////////////////////////////////////////////////////

SOURCE_NIST="nist";
SOURCE_UNKNOWN="unknow";

CVE_ITEM_STATUS_NEW = 0; // newly add
CVE_ITEM_STATUS_ANALYZED = 1; // item analyzed



////////////////////////////////////////////////////////////////////
// FUNCTION
////////////////////////////////////////////////////////////////////

function getMatchList(desc, valList){
    var tagsList = [];
    desc_lower = desc.toLowerCase();
    valList.forEach(function(element){
        var pos = desc_lower.indexOf(element);
        if (pos >= 0){
            tagsList.push(element);
        }
    });

    log.d(`Found : ${tagsList}`);
    return tagsList;
}

function getTagList(desc){
    log.d(`Get tag list from ${desc}`);
    return getMatchList(desc, Object.values(TAG_CTRL.getVulTags()));
}


function getModuleList(desc){
    log.d(`Get module list from ${desc}`);
    return getMatchList(desc, DEFAULT_MODULES);
}
function buildDesc(lang, desc){
    return {
        lang:lang,
        desc:desc
    }
};

/**
 * Analyze cve item
 * @param {*} item item to analyze, shall be update directly
 */
function analyzeItem(item){
    log.d(`Analyze cve item ${item.cve_number}`);
    desc = item.getDesc();
    item.tag = getTagList(desc);
    // module = getModuleList(desc);
    // module.forEach(element=>item.module[element] = []);
    // item.status = CVE_ITEM_STATUS_ANALYZED;
    return ERR.ErrNone;
}



/**
 * Convert CVE item to CVE db object
 * @param {*} item 
 * @returns cve_db object if ok, null otherwise
 */
function cveItem2cveDb(item){
    return null;
}

/**
 * Convert CVE DB to CVE Item
 * @param {*} cve 
 * @returns cve item if ok, null otherwise
 */
function cveDb2cveItem(cvedb, item = null){    
    var cve_item = item;
    if (!cve_item){
        cve_item = buildItem();
    }
    // TODO: validate info

    if (COMMON.isValidObj(cvedb._id)) cve_item.id = cvedb._id;
    if (COMMON.isValidObj(cvedb.cve_number)) cve_item.cve_number = cvedb.cve_number;
    if (COMMON.isValidObj(cvedb.vul_number)) cve_item.vul_number = cvedb.vul_number;
    if (COMMON.isValidObj(cvedb.importId)) cve_item.importId = cvedb.importId;
    // cvedb.cve_desc.forEach(desc => cve_item.desc.push(COMMON.fromBase64(desc)));
    if (COMMON.isValidObj(cvedb.cve_desc)) cvedb.cve_desc.forEach(desc => cve_item.desc.push(desc));
    // cvedb.cve_ref_url.forEach(ref => cve_item.ref.push(COMMON.fromBase64(ref)));
    if (COMMON.isValidObj(cvedb.cve_ref_url)) cvedb.cve_ref_url.forEach(ref => cve_item.ref.push(ref));
    if (COMMON.isValidObj(cvedb.source)) cve_item.source = cvedb.source;
    if (COMMON.isValidObj(cvedb.tag)) cvedb.tag.forEach(tag => cve_item.tag.push(tag));
    if (COMMON.isValidObj(cvedb.module))
    {
        if (cvedb.module != null && cvedb.module != undefined){
            for (const key of cvedb.module.keys()) {
                cve_item.module[key] = cvedb.module.get(key);
            }
        }
        else{
            cve_item.module = {};
        }

    }

    if (COMMON.isValidObj(cvedb.cve_pubished_date)) cve_item.cve_publishedDate = cvedb.cve_pubished_date;
    if (COMMON.isValidObj(cvedb.cve_modified_date)) cve_item.cve_lastModifiedDate = cvedb.cve_modified_date;
    if (COMMON.isValidObj(cvedb.added_date)) cve_item.added_date = cvedb.added_date;
    if (COMMON.isValidObj(cvedb.history)) cve_item.history = cvedb.history;
    if (COMMON.isValidObj(cvedb.cve_impactScore)) cve_item.impactScore = cvedb.cve_impactScore;
    if (COMMON.isValidObj(cvedb.cve_baseScore)) cve_item.baseScore = cvedb.cve_baseScore;
    if (COMMON.isValidObj(cvedb.cve_severity)) cve_item.severity = cvedb.cve_severity;
    if (COMMON.isValidObj(cvedb.cve_accessVector)) cve_item.vectorAttack = cvedb.cve_accessVector;
    if (COMMON.isValidObj(cvedb.cve_vectorString)) cve_item.vectorString = cvedb.cve_vectorString;
    if (COMMON.isValidObj(cvedb.status)) cve_item.status = cvedb.status;


    return cve_item;
}

function buildItem(source=SOURCE_UNKNOWN){
    log.d("Build cve item");
    return {
        id:null,
        vul_number:null,
        cve_number:null,
        importId:null,
        desc:[],
        ref:[],
        tag:[],
        
        modules:[], // list of module ids
        projects:[], // list of project ids
        source:source,
        last_modified_date:null,
        added_date:null,
        history:null,
        cve_publishedDate:null,
        cve_lastModifiedDate:null,
        impact:null,
        vectorString:null,
        vectorAttack:null,
        baseScore:0,
        exploitabilityScore:0,
        impactScore:0,
        severity:0
        , status:CVE_ITEM_STATUS_NEW
        , poc:null
        , file:null
        , reportedBy:null
        , toString: function(){
            return `${this.id}, ${this.vul_number}`;
        }
        , getDesc:function(){
            var desc = `[${this.source}]`;
            this.desc.forEach(element => desc += element+ "\n");
            return desc;
        }
        , getRef:function(){
            var ref = `[${this.source}] `;
            this.ref.forEach(element => ref += element + "\n");
            return ref;
        }
        , getTag:function(){
            tag = "";
            this.tag.forEach(element => tag += element + ",");
            return tag;
        }
        , buildTag: function(tags = null){

            log.i(`build tags for ${this.vul_number}`);
            var tagsList = [];
            if (tags == null){
                tags = Object.values(TAG_CTRL.getVulTags());
                log.d("use default tag list");
            }
            desc = this.getDesc();
            desc_lower = desc.toLowerCase();
            tags.forEach(function(element){
                var pos = desc_lower.indexOf(element);
                if (pos >= 0){
                    tagsList.push(element);
                }
            });

            log.d(`Found tags: ${tagsList}`);
            return tagsList;
        },
        
    };
}
////////////////////////////////////////////////////////////////////
// MODULE EXPORT
////////////////////////////////////////////////////////////////////

exports.buildDesc = buildDesc

exports.addDesc = function(lang, desc, item){
    item.desc.push(buildDesc(lang, desc));
    return item;
}

exports.buildItem = buildItem;


exports.SOURCE_NIST = SOURCE_NIST;
exports.getTagList = getTagList;
exports.getModuleList = getModuleList;
exports.analyzeItem = analyzeItem;
exports.cveDb2cveItem = cveDb2cveItem;
