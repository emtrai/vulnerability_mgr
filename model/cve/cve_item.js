
/**
 * Copyright (C) 2022 Anh Huy Ngo - All Rights Reserved
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * 
 * Author: Anh Ngo
 * Created Date: 
 */
////////////////////////////////////////////////////////////////////
// MODULE LOADING
////////////////////////////////////////////////////////////////////

var ERR = require("../../errno");
var log = require("../../log").build("cve_item");


////////////////////////////////////////////////////////////////////
// GLOBAL VARIABLES
////////////////////////////////////////////////////////////////////

SOURCE_NIST="nist";
SOURCE_UNKNOWN="unknow";

CVE_ITEM_STATUS_NEW = 0; // newly add
CVE_ITEM_STATUS_ANALYZED = 1; // item analyzed

const DEFAULT_TAGS = [
    "** disputed **",
    "** reserved **",
    // os
    "linux", 
    "kernel", 
    "android", 
    "windows", 
    "ubuntu", 
    "solaris", 
    "opensuse",
    "ios",
    "ipados",
    "freebsd",
    "debian",
    "ubuntu",
    "pan-os",
    "suse",
    "op-tee",
    //platform
    "mac", 
    "x86", 
    "amd",   
    "arm", 
    "powerpc", 
    "exynos", 
    "aarch64", 
    "snapdragon",
    "s390",
    //module/componen
    "openssl", 
    "busybox", 
    "ntpd", 
    "libc", 
    "curl", 
    "usb", 
    "driver",
    "bash",
    "boost",   
    "gdb",   
    "gimp",   
    "glib",   
    "json",   
    "python",   
    "zip",   
    "gnu",   
    "lib",    
    "crypto",   
    "media",   
    "net",   
    "block",   
    "fs",   
    "sound",   
    "qcom",   
    "drm",   
    "ipv4",   
    "ipv6",   
    "gpu",   
    "xen",
    "router",
    "apache",
    "vpn",
    "firefox",
    "chrome",
    "tcp",
    "udp",
    "netfilter",
    "ssl",
    "tls",
    "ftp",
    "sql",
    "dns",
    "ipc",
    "dll",
    "wifi",
    "wireless",
    "server",
    "java",
    "camera",
    "nfc",
    "bios",
    "graphic",
    "bluetooth",
    ".net",
    "nginx",
    "directX",
    "explorer",
    "vmware",
    "gateway",
    "studio",
    "bz2",
    " rar ",
    "zip",
    "tar",
    "sudo",
    "ldap",
    "selinux",
    "pgp",
    "ssh",
    "v4l",
    "docker",
    "ethernet",
    "boot",
    "gnome",
    "fpu",
    " abi ",
    "tty",
    "serial",
    "grub",
    "uefi",
    "fbcon",
    "virus-detection",
    "tomcat",
    "nfs",
    "unix",
    //vendor
    "adobe",
    "intel",
    "microsoft",
    "cisco",
    "google",
    "dell",
    "nvidia",
    "postgre",
    "samsung",
    "foxit",
    "mediatek",
    "mtk",
    "red hat",
    "ibm",
    //attack   
    "crash",   
    "privilege",   
    "denial",   
    "arbitrary",   
    "root",  
    "remote",  
    "xss",  
    "overflow",  
    "dereference",  
    "use after free",  
    "use-after-free",  
    "out-of-bounds",  
    "injection",  
    "memory",
    "flaw",  
    "bypass",  
    "traversal",
    "disclosure",
    ]

// TODO: read from file???
 DEFAULT_MODULES=[
    "linux",
    "android",
    "juniper",
    "junos",
    "openssl",
    "curl",
    "glibc",
    "libxml",
    "busybox",

 ]   


////////////////////////////////////////////////////////////////////
// FUNCTION
////////////////////////////////////////////////////////////////////

function getMatchList(desc, valList){
    var tagsList = [];
    desc_lower = desc.toLowerCase();
    valList.forEach(function(element){
        var pos = desc_lower.indexOf(element);
        if (pos >= 0){
            tagsList.push(element);
        }
    });

    log.d(`Found : ${tagsList}`);
    return tagsList;
}

function getTagList(desc){
    log.d(`Get tag list from ${desc}`);
    return getMatchList(desc, DEFAULT_TAGS);
}


function getModuleList(desc){
    log.d(`Get module list from ${desc}`);
    return getMatchList(desc, DEFAULT_MODULES);
}
function buildDesc(lang, desc){
    return {
        lang:lang,
        desc:desc
    }
};

/**
 * Analyze cve item
 * @param {*} item item to analyze, shall be update directly
 */
function analyzeItem(item){
    log.d(`Analyze cve item ${item.cve_id}`);
    desc = item.getDesc();
    item.tag = getTagList(desc);
    // module = getModuleList(desc);
    // module.forEach(element=>item.module[element] = []);
    // item.status = CVE_ITEM_STATUS_ANALYZED;
    return ERR.ErrNone;
}



/**
 * Convert CVE item to CVE db object
 * @param {*} item 
 * @returns cve_db object if ok, null otherwise
 */
function cveItem2cveDb(item){
    return null;
}

/**
 * Convert CVE DB to CVE Item
 * @param {*} cve 
 * @returns cve item if ok, null otherwise
 */
function cveDb2cveItem(cvedb, item = null){    
    var cve_item = item;
    if (!cve_item){
        cve_item = buildItem();
    }
    // TODO: validate info

    cve_item.id = cvedb._id;
    cve_item.cve_id = cvedb.cve_id;
    cve_item.vul_id = cvedb.vul_id;
    cve_item.importId = cvedb.importId;
    // cvedb.cve_desc.forEach(desc => cve_item.desc.push(COMMON.fromBase64(desc)));
    cvedb.cve_desc.forEach(desc => cve_item.desc.push(desc));
    // cvedb.cve_ref_url.forEach(ref => cve_item.ref.push(COMMON.fromBase64(ref)));
    cvedb.cve_ref_url.forEach(ref => cve_item.ref.push(ref));
    cve_item.source = cvedb.source;
    cvedb.tag.forEach(tag => cve_item.tag.push(tag));
    if (cvedb.module != null && cvedb.module != undefined){
        for (const key of cvedb.module.keys()) {
            cve_item.module[key] = cvedb.module.get(key);
        }
    }
    else{
        cve_item.module = {};
    }

    cve_item.cve_publishedDate = cvedb.cve_pubished_date;
    cve_item.cve_lastModifiedDate = cvedb.cve_modified_date;
    cve_item.added_date = cvedb.added_date;
    cve_item.history = cvedb.history;
    cve_item.impactScore = cvedb.cve_impactScore;
    cve_item.baseScore = cvedb.cve_baseScore;
    cve_item.severity = cvedb.cve_severity;
    cve_item.vectorAttack = cvedb.cve_accessVector;
    cve_item.vectorString = cvedb.cve_vectorString;
    return cve_item;
}

function buildItem(source=SOURCE_UNKNOWN){
    log.d("Build cve item");
    return {
        id:null,
        vul_id:null,
        cve_id:null,
        importId:null,
        desc:[],
        ref:[],
        tag:[],
        // module:{}, // key: name, value: array of version
        modules:[],
        projects:[], 
        source:source,
        last_modified_date:null,
        added_date:null,
        history:null,
        cve_publishedDate:null,
        cve_lastModifiedDate:null,
        impact:null,
        vectorString:null,
        vectorAttack:null,
        baseScore:0,
        exploitabilityScore:0,
        impactScore:0,
        severity:0
        , status:CVE_ITEM_STATUS_NEW
        , poc:null
        , file:null
        , reportedBy:null
        , toString: function(){
            return `${this.id}, ${this.vul_id}`;
        }
        , getDesc:function(){
            var desc = `[${this.source}]`;
            this.desc.forEach(element => desc += element+ "\n");
            return desc;
        }
        , getRef:function(){
            var ref = `[${this.source}] `;
            this.ref.forEach(element => ref += element + "\n");
            return ref;
        }
        , getTag:function(){
            tag = "";
            this.tag.forEach(element => tag += element + ",");
            return tag;
        }
        , buildTag: function(tags = null){

            log.i(`build tags for ${this.vul_id}`);
            var tagsList = [];
            if (tags == null){
                tags = DEFAULT_TAGS;
                log.d("user default tag list");
            }
            desc = this.getDesc();
            desc_lower = desc.toLowerCase();
            tags.forEach(function(element){
                var pos = desc_lower.indexOf(element);
                if (pos >= 0){
                    tagsList.push(element);
                }
            });

            log.d(`Found tags: ${tagsList}`);
            return tagsList;
        },
        
    };
}
////////////////////////////////////////////////////////////////////
// MODULE EXPORT
////////////////////////////////////////////////////////////////////

exports.buildDesc = buildDesc

exports.addDesc = function(lang, desc, item){
    item.desc.push(buildDesc(lang, desc));
    return item;
}

exports.buildItem = buildItem;


exports.SOURCE_NIST = SOURCE_NIST;
exports.getTagList = getTagList;
exports.getModuleList = getModuleList;
exports.analyzeItem = analyzeItem;
exports.cveDb2cveItem = cveDb2cveItem;
