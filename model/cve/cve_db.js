/**
 * Copyright (C) 2022 Anh Huy Ngo - All Rights Reserved
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * 
 * Author: Anh Ngo
 * Created Date: 
 */
////////////////////////////////////////////////////////////////////
// MODULE LOADING
////////////////////////////////////////////////////////////////////
const { UUID } = require('bson');
var MONGOOSE = require('mongoose')
var DB = require('../../db/db');
var COMMON = require('../../common');
var CVEITEM = require('./cve_item');
var ERR = require("../../errno");
var log = require("../../log").build("cvedb");
var PROJECT_CVE_DB = require("../project/project_cve_db");
var MODULE_CVE_DB = require("../module/module_cve_db");
////////////////////////////////////////////////////////////////////
// GLOBAL VARIABLES
////////////////////////////////////////////////////////////////////

const CVE_STATUS_NOT_READY = 0;
const CVE_STATUS_READY = 1;
const CVE_STATUS_DUP = 2;
const CVE_STATUS_DEL = 3;

const SCHEMA_NAME = "cve";

MONGOOSE.pluralize(null);

var cve_schema = new MONGOOSE.Schema({
    vul_id:String, // Vulnerability ID, can be CVE if already allocated, or any other id like BDSAxxx from Synopsys Blackduck
    // CVE information
    cve_id:String, // CVE ID, if vulnerability already alocate cve number
    cve_desc:[String], // description, an array of desc by languate
    cve_pubished_date:Number, // publish date, in milisecond, utc+0
    cve_modified_date:Number,
    cve_security_risk:Number, // critical, high, mid, low
    cve_impact:String, // impact, in raw data
    // impact (extracted)
    cve_severity:String,
    cve_exploitabilityScore:Number,
    cve_impactScore:Number,
    cve_vectorString:String,
    cve_accessVector:String,
    cve_baseScore:Number,
    cve_ref_url:[String],
    cve_overal_score:Number,
    cve_patch_link:String,

    // meta info
    
    source:[String], // nist, nvd, blackduck, etc
    tag:[String],
    // module:[String],
    note:String,
    poc:String, // Proof of concept
    files:String,//Uploaded files information (single file)
    reportedBy:String, // name of reporter
    import_source:MONGOOSE.ObjectId, // import source, link to cve_import
    module:{ // key: module id, value: version list
        type:Map, 
        of:[String] // version list of module
    },
    nist_base_core:String,
    added_date:Number, // imported date, in milisecond
    last_modified_date:Number, // last modification date
    last_view_date:Number, // last view date in ms
    history:String, // history string
    hash:String, // hashstring to check match/diff cve
    status:Number, // status: 0: NOT READY, 1: READY, 2: DUP, 3: DELETED
    importId:String, // importer ID string
});

var CVE = MONGOOSE.model(SCHEMA_NAME, cve_schema);


////////////////////////////////////////////////////////////////////
// FUNCTION
////////////////////////////////////////////////////////////////////

function add(cveitem){
    log.d("add cve: " + cveitem.cve_id);
    return new Promise ((resolve, reject) => {
        log.d("find cve: " + cveitem.cve_id);
        DB.connectdbsync(null);
        CVE.findOne({cve_id:cveitem.cve_id}, async function(err, cve){
            log.d(`findOne callback ${cveitem.cve_id}`);
            if (cve){
                log.i(`CVE ${cveitem.cve_id} already exist`);
                cveitem.id = cve._id;
                reject(COMMON.buildError(`${cveitem.cve_id} already existed`, ERR.ErrExist, cveitem, err))
                // if (callback)
                //     callback(ERR.ErrExist, cveitem);
            }
            else{
                log.i(`CVE ${cveitem.cve_id} not exist, create new`);
                
                var cvedb = new CVE();
                cvedb.cve_id = cveitem.cve_id;
                cvedb.vul_id = cveitem.cve_id;

                log.d(cveitem.desc);
                if (cveitem.desc){
                    cvedb.cve_desc = [];
                    log.d(`############## build description for ${cvedb.cve_id} ###########`);
                    cveitem.desc.forEach(function(element){
                        // log.d("####\n\n");
                        // log.d(`desc ${element}`);
                        // cvedb.cve_desc.push(COMMON.toBase64(element));
                        cvedb.cve_desc.push(element);


                        // log.d("\n\n");
                        // log.d(`${cvedb.cve_id} >>>> ${cvedb.cve_desc}`);
                    });
                }

                cvedb.cve_ref_url = [];
                cvedb.added_date = cveitem.added_date;
                cvedb.last_modified_date = cveitem.last_modified_date;
                if (cveitem.ref){
                    // cveitem.ref.forEach(element => cvedb.cve_ref_url.push(COMMON.toBase64(element)));
                    cveitem.ref.forEach(element => cvedb.cve_ref_url.push(element));
                }
                //tag
                if (cveitem.tag){
                    cveitem.tag.forEach(element => cvedb.tag.push(element));
                }
                // source
                if (cveitem.source){
                    cvedb.source.push(cveitem.source);
                }
                if (cveitem.impact){
                    cvedb.cve_impact = COMMON.toBase64(cveitem.impact);
                }
                if (cveitem.vectorAttack){               
                    cvedb.cve_accessVector = cveitem.vectorAttack;
                }
                if (cveitem.vectorString){
                    cvedb.cve_vectorString = cveitem.vectorString;
                }
                if (cveitem.baseScore){
                    cvedb.cve_baseScore = cveitem.baseScore;
                }
                if (cveitem.exploitabilityScore){
                    cvedb.cve_exploitabilityScore = cveitem.exploitabilityScore;
                }
                if (cveitem.impactScore){
                    cvedb.cve_impactScore = cveitem.impactScore;
                }
                if (cveitem.severity){
                    cvedb.cve_severity= cveitem.severity;
                }
                if (cveitem.importId){
                    cvedb.importId= cveitem.importId;
                }
                

                log.d(`Save ${cvedb.cve_id} to db`);
                cvedb.save(function(err, saveditem){
                    log.d(`Save cve ${cveitem.cve_id} callback`);
                    if (err){
                        var msg = `Added ${cveitem.cve_id} Failed ${err}`;
                        log.i(msg);
                        reject(COMMON.buildError(msg, ERR.ErrFailed, cveitem, err));
                    }
                    else
                    {

                        log.i(`Added ${cveitem.cve_id} OK`);
                        cveitem.id = saveditem._id;
                        resolve(CVEITEM.cveDb2cveItem(saveditem));
                    }
                });
                
                // TODO: handle error case
            }
        // });
        });
            
    })
    // return ERR.ErrNone;
}

function getAll(page = 1, perpage = 5, callback = null){
    log.i("Get all cves");
    log.d(`page ${page}, perpage ${perpage}`)
    DB.connectdbsync(null);
    CVE.count(function(err, count) {
        if (err) {
            log.e("Get all failed, cannot count");
            log.e(err);
            return;
        }
        log.d(`CVE count ${count}`);
        var totalpages = (count/perpage + 1) | 0;
        // var totalpages = (page + 1)*perpage >= count;
        log.d(`totalpages ${totalpages}`);
        CVE.find({})
            // .sort('vul_id',1)
            .skip((page-1) * perpage)
            .limit(perpage)
            .exec(function(err, cves){

            var cve_items = [];
            if (cves){
                log.i("Found cves");
                cves.forEach(function(element){
                    log.i(`found cve ${element.cve_id}`);
                    var item = CVEITEM.cveDb2cveItem(element);
                    
                    cve_items.push(item);
                    
                });
            }
            else{
                log.i("not found any cve");
            }
            
            callback(cve_items, totalpages);
        });
    });
}

// function search(keyword, page = 1, perpage = 5, callback = null, fields=null){
function search(keyword, page = 1, perpage = 5, fields=null){
    log.d(`Search keyword: ${keyword}`);
    log.d(`page ${page} perpage ${perpage}`)
    return new Promise((resolve, reject) => {
        let regex = new RegExp(keyword,'i');
        const filterd = CVE.find(
            { $or: [{cve_id: regex },{cve_desc: regex}] }
            )
            .skip((page-1) * perpage)
            .limit(perpage)
            .exec(function(err, cves){
    
                var cve_items = [];
                if (cves){
                    log.i("Found cves");
                    cves.forEach(function(element){
                        log.i(`found cve ${element.cve_id}`);
                        var item = CVEITEM.cveDb2cveItem(element);
                        
                        cve_items.push(item);
                        
                    });
                }
                else{
                    log.i("not found any cve");
                }
                var totalpages = (cve_items.length/perpage + 1) | 0;
                log.d(`total ${totalpages} per ${perpage}`)
                resolve({cves:cve_items, totalpages:totalpages});
            });
    });
    
}

function getByAnyId(id){
    log.d(`getByAnyId: ${id}`);
    return new Promise((resolve, reject) => {
        DB.connectdbsync(null);
        var conditions = [
            { vul_id:id },
            { cve_id:id }
        ]
        if (MONGOOSE.isValidObjectId(id)){
            conditions.push({_id:id});
        }
        // log.dumpArray(conditions, "Condition");

        CVE.findOne({ 
                    $or: conditions
                    }, 
                function(err, cve){
            log.d(`getByAnyId findOne callback ${id}`);
            if (!err){
                if (cve){
                    var item = CVEITEM.cveDb2cveItem(cve);
                    log.d(`Found one cve ${item.toString()}`);
                    resolve(item);
                }
                else{
                    var errMsg = `Get cve by id ${id} failed: NOT found`;
                    log.e(errMsg);
                    reject(COMMON.buildError(errMsg, ERR.ErrNotFound, id));
                }
                
            }
            else{
                var errMsg = `Get cve by id ${id} failed: ${err}`;
                log.e(errMsg);
                reject(COMMON.buildError(errMsg, ERR.ErrFailed, id, err));
            }
        });
    });
}


function getCVEbyProject(projectId, page = 1, perpage = 5){

    log.d(`getCVEbyProject ${projectId}`);
    log.d(`page ${page}, perpage ${perpage}`)
    return new Promise((resolve, reject) => {
        DB.connectdbsync(null);
        var query = [
            {
                $lookup: {
                    from:PROJECT_CVE_DB.SCHEMA_NAME, // collection name in db
                    localField: "_id",
                    foreignField: "cveId",
                    as: "projectinfo"
                },
            },
            {   $unwind:"$projectinfo" },
            {
                $match:{
                    $and:[{"projectinfo.projectId" : MONGOOSE.Types.ObjectId(projectId)}]
                }
            }
    
        ];
        log.d(`Count the number of item`);
        // console.log(query);
        PROJECT_CVE_DB.countCVE(projectId).then(count => {
                log.d(`getCVEbyProject count callback ${count}`);
                // if (err){
                //     var msg = `Count cve of project ${projectId} failed: ${err}`;
                //     reject(COMMON.buildError(msg, ERR.ErrFailed, err));
                // }
                // else{
                
                if (count > 0){
                    log.d(`getCVEbyProject ${projectId} query, page ${page}, perpage ${perpage}`);
                    CVE.aggregate(query)
                        .skip((page-1) * perpage)
                        .limit(perpage)
                        .exec(function(err, cves) {
                    
                            log.d(`getCVEbyProject ${projectId} CALLBACK`);
                                var cve_items = [];
                                if (err){
                                    reject(COMMON.buildError(`Failed to get cve of project ${projectId}`, ERR.ErrFailed, err));
                                }
                                else{
                                    log.i(`Found cves ${cves.length}`);
                                    cves.forEach(function(element){
                                        log.i(`found cve ${element.cve_id}`);
                                        var item = CVEITEM.cveDb2cveItem(element);
                                        
                                        cve_items.push(item);
                                        
                                    });
                                    var totalpages = (cve_items.length/perpage + 1) | 0;
                                    resolve({cves:cve_items, totalpages:totalpages})
                                }
                                // callback(cve_items, totalpages);
                            }); 
                }
                else{
                    resolve({cves:[], totalpages:0})
                }
                // }
            });
    
    });

    // CVE.count(function(err, count) {
    //     if (err) {
    //         log.e("Get all failed, cannot count");
    //         log.e(err);
    //         return;
    //     }
    //     log.d(`CVE count ${count}`);
    //     var totalpages = (count/perpage + 1) | 0;
    //     // var totalpages = (page + 1)*perpage >= count;
    //     log.d(`totalpages ${totalpages}`);
    //     CVE.find({})
    //         // .sort('vul_id',1)
    //         .skip((page-1) * perpage)
    //         .limit(perpage)
    //         .exec(function(err, cves){

    //         var cve_items = [];
    //         if (cves){
    //             log.i("Found cves");
    //             cves.forEach(function(element){
    //                 log.i(`found cve ${element.cve_id}`);
    //                 var item = CVEITEM.cveDb2cveItem(element);
                    
    //                 cve_items.push(item);
                    
    //             });
    //         }
    //         else{
    //             log.i("not found any cve");
    //         }
            
    //         callback(cve_items, totalpages);
    //     });
    // });
}


function getCVEbyModule(moduleId, page = 1, perpage = 5){

    log.d(`getCVEbyModule ${moduleId}`);
    log.d(`page ${page}, perpage ${perpage}`)
    return new Promise((resolve, reject) => {
        DB.connectdbsync(null);
        var query = [
            {
                $lookup: {
                    from:MODULE_CVE_DB.SCHEMA_NAME, // collection name in db
                    localField: "_id",
                    foreignField: "cveId",
                    as: "moduleinfo"
                },
            },
            {   $unwind:"$moduleinfo" },
            {
                $match:{
                    $and:[{"moduleinfo.moduleId" : MONGOOSE.Types.ObjectId(moduleId)}]
                }
            }
    
        ];
        log.d(`Count the number of item`);
        // console.log(query);
        MODULE_CVE_DB.countCVE(moduleId).then(count => {
                log.d(`getCVEbyModule count callback ${count}`);
                
                if (count > 0){
                    log.d(`getCVEbyModule ${moduleId} query, page ${page}, perpage ${perpage}`);
                    CVE.aggregate(query)
                        .skip((page-1) * perpage)
                        .limit(perpage)
                        .exec(function(err, cves) {
                    
                            log.d(`getCVEbyModule ${moduleId} CALLBACK`);
                                var cve_items = [];
                                if (err){
                                    reject(COMMON.buildError(`Failed to get cve of module ${moduleId}`, ERR.ErrFailed, err));
                                }
                                else{
                                    log.i(`Found cves ${cves.length}`);
                                    cves.forEach(function(element){
                                        log.i(`found cve ${element.cve_id}`);
                                        var item = CVEITEM.cveDb2cveItem(element);
                                        
                                        cve_items.push(item);
                                        
                                    });
                                    var totalpages = (cve_items.length/perpage + 1) | 0;
                                    resolve({cves:cve_items, totalpages:totalpages})
                                }
                            }); 
                }
                else{
                    resolve({cves:[], totalpages:0})
                }
                // }
            });
    
    });

}

////////////////////////////////////////////////////////////////////
// MODULE EXPORT
////////////////////////////////////////////////////////////////////

module.exports.add = add;
module.exports.getAll = getAll;
module.exports.getByAnyId = getByAnyId;
module.exports.getCVEbyProject = getCVEbyProject;
module.exports.getCVEbyModule = getCVEbyModule;
module.exports.search = search;