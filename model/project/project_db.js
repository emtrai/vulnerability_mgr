/**
 * Copyright (C) 2022 Anh Huy Ngo - All Rights Reserved
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * 
 * Author: Anh Ngo
 * Created Date: 
 */

////////////////////////////////////////////////////////////////////
// MODULE LOADING
////////////////////////////////////////////////////////////////////

var ERR = require("../../errno");
var COMMON = require("../../common");

var DB = require('../../db/db');
const { UUID } = require('bson');
var MONGO = require('mongoose')

var PROJECT_MODULE = require('./project_module_db');
var MODULE = require('../module/module_db');
////////////////////////////////////////////////////////////////////
// GLOBAL VARIABLES
////////////////////////////////////////////////////////////////////
const SCHEMA_NAME = "project";
var log = require("../../log").build("projectdb");

MONGO.pluralize(null);

// project include multiple domain
var project_schema = new MONGO.Schema({
    nameid:String, // use name as id, to check duplicate
    name:String, // project name, such as telematic, infotainment, phoneapp, smsapp, etc.
    parentId:MONGO.ObjectId, // parent project id, inherit all information
    status:{type:Number, default:DB.STATUS_INACTIVE}, // status: active, on-hold, etc.
    // can be used to mark as tag, may include market, variant, parent component, domain
    // such as: project "telematic" can be add following tags: ecockpit, eu, vn, bev, ice, etc.
    tags:[String], 
    desc:String, // description of project
    history:String,// history of component
    created_date:Number, // date of creation
    modified_date:Number, // last modified time
});

var PROJECTS = MONGO.model(SCHEMA_NAME, project_schema);

////////////////////////////////////////////////////////////////////
// FUNCTION
////////////////////////////////////////////////////////////////////
function buildItem(){
    log.d("Build cve item");
    return {
        id:null,
        parentId:null,
        status: DB.STATUS_INACTIVE,
        nameid:null,
        name:null,
        desc:null,
        tags:[],
        modules:[],
        noCVE:0,
        toString:function(){
            return `${this.id},${this.name},${this.nameid}, ${this.status}, ${this.getTag()}`;
        },
        getTag:function(){
            tags = "";
            this.tags.forEach(element => tags += element + ",");
            return tags;
        }
    };
}

function db2Item(prjdb, item = null){    
    var prjitem = item;
    if (!prjitem){
        prjitem = buildItem();
    }
    // TODO: validate info

    prjitem.id = prjdb._id;
    prjitem.name = prjdb.name;
    prjitem.nameid = prjdb.nameid;
    prjitem.desc = prjdb.desc;
    prjitem.parentId = prjdb.parentId;
    prjitem.status = prjdb.status;
    prjdb.tags.forEach(tag => prjitem.tags.push(tag));
    
    return prjitem;
}


/**
 * Get project from db, if not exist, build one
 */
function getListProject(callback){
    log.d("getListProject");
    
    DB.connectdbsync(null);
    PROJECTS.find({})
        .sort('name')
        .exec(function(err, prjs){
            var items = [];
            if (prjs){
                log.i("Found items");
                prjs.forEach(function(element){
                    log.i(`found prj ${element.cve_id}`);
                    var item = db2Item(element);
                    items.push(item);
                    
                });
            }
            else{
                log.i("not found any cve");
            }
            
            callback(ERR.ErrNone, items);
    });
    

}


// return Promise
function add(item){
    log.i(`add project ${item.toString()}`);
    return new Promise((resolve, reject) => {
        // TODO: validate input
        DB.connectdbsync(null);
        item.nameid = COMMON.str2strId(item.name);
        PROJECTS.findOne({nameid:item.nameid}, async function(err, prj){
            log.d(`add findOne callback ${item.name}`);
            var ret = ERR.ErrFailed;
            var ret_msg = "Failed";
            if (prj){
                ret_msg = `prj ${item.name} already existed`;
                log.e(ret_msg);
                ret = ERR.ErrExist;
                // reject(new Error(ret_msg));
                reject(new COMMON.buildError(ret_msg, ret, item));
            }
            else{
                            
                var prjdb = new PROJECTS();
                log.i(`prj ${item.name} not exist, create new`);
                prjdb.nameid = item.nameid;
                prjdb.name = item.name;
                prjdb.desc = item.desc;
                prjdb.parentid = item.parentid;
                prjdb.tags = [];
                if (item.tags){
                    item.tags.forEach(element => prjdb.tags.push(element));
                }
                
                prjdb.created_date = COMMON.currentTimeMs();
                prjdb.modified_date = COMMON.currentTimeMs();
                // TODO: update history?
                
                prjdb.save(function(err, prj){
                    
                    // TODO: check err
                    var ret = ERR.ErrNone;
                    var ret_msg = "Add new prj OK"
                    if (!err){
                        item.id = prj._id;
                        log.i(`Added prj ${item.name} OK, id ${item.id}`);
                        resolve(item);
                    }
                    else{

                        ret_msg = `Added prj ${item.name} Failed ${err}`;
                        log.i(ret_msg);
                        ret = ERR.ErrFailed;
                        reject(new COMMON.buildError(ret_msg, ret, item, err));
                    }
                    // resolve(item);
                    // if (callback){
                    //     callback( ret, item, ret_msg);
                    // }
                });
                
                // TODO: handle error case
            }
    
    
        });
        // }.bind({item:Object.assign({}, item)})); // TODO: need to bind callback? is it risk of duplicate callback????
        // return ERR.ErrNone;
    });
    
}

function update(item, callback){
    log.i(`update ${item.toString()}`);
    DB.connectdbsync(null);
    PROJECTS.findOne({_id:item.id}, async function(err, prj){
        log.d(`update findOne callback ${this.name}`);
        if (prj){
            log.i(`prj ${this.name} already exist`);
            log.d(module.version);
            var ret = ERR.ErrFailed;
            var ret_msg = "Failed";
            prj.name = item.name;
            prj.parentId = item.parentId;
            prj.status = item.status;
            prj.nameid = item.nameid;
            prj.desc = item.desc;
            prj.nameid = item.nameid;
            if (item.tags){
                item.tags.forEach(element => prj.tags.push(element));
            }
            
            prj.modified_date = COMMON.currentTimeMs();
            // TODO: update history?
            
            prj.save(function(err, prj){
                log.i(`Update project ${item.toString()} OK`);
                // TODO: check err
                if (callback){
                    callback( ERR.ErrNone, item, `Update project ${item.name} OK`);
                }
            });
        }
        else{
            ret = ERR.ErrNotFound;
            ret_msg = `prj ${this.name} Not FOUND`;
            log.e(ret_msg); 
            if (callback)
                callback(ret, this.name, ret_msg);
        }
        
    });
    return ERR.ErrNone;
}

function checkIfProjectIdExist(projectId){
    log.d(`checkIfProjectIdExist ${projectId}`);
    return new Promise((resolve, reject) => {
        // var condition = [];
        // if (Array.isArray(projectId))
        // {
        //     if (!COMMON.isEmpty(projectId)){
        //         projectId.forEach(element => {
        //             condition.push({_id:element})
        //         })
        //     }
                
        // }
        // else{
        //     condition.push({_id:projectId})
        // }
        if (MONGO.isValidObjectId(projectId))
        {
            PROJECTS.find({ _id:projectId}, function(err, items) {
                log.d(`checkIfProjectIdExist callback ${projectId}`);
                if (!err){
                    log.d(`items ${items}`);
                    resolve(!COMMON.isEmpty(items));
                }
                else{
                    var msg = `Count cve of prj ${projectId} failed. ${err}`;
                    log.e(msg);
                    reject(COMMON.buildError(msg, ERR.ErrFailed, projectId, err));
                }
            });
            
        }
        else{
            log.d(`checkIfProjectIdExist ${projectId} is not ObjectID`);
            resolve(false);
        }
    })

}

////////////////////////////////////////////////////////////////////
// MODULE EXPORT
////////////////////////////////////////////////////////////////////
// module.exports = project;
exports.getListProject = getListProject;
exports.checkIfProjectIdExist = checkIfProjectIdExist;
exports.add = add;

exports.buildItem = buildItem;

exports.SCHEMA_NAME = SCHEMA_NAME;