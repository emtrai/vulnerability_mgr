const { UUID } = require('bson');
var mongoose = require('mongoose')
var ModDb = require('../db/db');
var ModCommon = require('../common');
var ModCVEItem = require('./cve_item');
var errno = require("../errno");
var log = require("../log").build("cve");

const CVE_STATUS_NOT_READY = 0;
const CVE_STATUS_READY = 1;
const CVE_STATUS_DUP = 2;
const CVE_STATUS_DEL = 3;

var cve_schema = new mongoose.Schema({
    cve_id:String, // CVE ID, if vulnerability already alocate cve number
    vul_id:String, // Vulnerability ID, can be CVE if already allocated, or any other id like BDSAxxx from Synopsys Blackduck
    cve_desc:[String],
    cve_pubished_date:Number, // publish date, in milisecond, utc+0
    cve_modified_date:Number,
    cve_security_risk:Number, // critical, high, mid, low
    cve_impact:String,
    cve_severity:String,
    cve_exploitabilityScore:Number,
    cve_impactScore:Number,
    cve_vectorString:String,
    cve_accessVector:String,
    cve_baseScore:Number,
    cve_ref_url:[String],
    cve_overal_score:Number,
    cve_patch_link:String,
    source:[String], // nist, nvd, blackduck, etc
    tag:[String],
    note:String,
    poc:String, // Proof of concept
    files:String,//Uploaded files information (single file)
    reportedBy:String, // name of reporter
    import_source:[mongoose.ObjectId], // import source
    module:{ // key: module id, value: version list
        type:Map, 
        of:[String] // version list of module
    },
    nist_base_core:String,
    added_date:Number, // imported date, in milisecond
    last_modified_date:Number, // last modification date
    last_view_date:Number, // last view date in ms
    history:String, // history string
    hash:String, // hashstring to check match/diff cve
    status:Number, // status: 0: NOT READY, 1: READY, 2: DUP, 3: DELETED
});

var CVE = mongoose.model("cve", cve_schema);
var CVE_TMP = mongoose.model("cve_tmp", cve_schema);



/**
 * Add cve item to database
 * Async call, return result via callback
 * @param {*} cve_item CVE information, refer @cve_item.js
 * @param {*} callback Callback(errorcode, cveitem)
 * @returns error code. If ErrNone, result via callback
 */
function add(item, callback){
    log.d("find cve: " + item.cve_id);
    CVE.findOne({cve_id:item.cve_id}, async function(err, cve){
        log.d(`findOne callback ${this.cveitem.cve_id}`);
        if (cve){
            log.i(`CVE ${this.cveitem.cve_id} already exist`);
            if (callback)
                callback(errno.ErrExist, this.cveitem);
        }
        else{
            log.i(`CVE ${this.cveitem.cve_id} not exist, create new`);
            
            var cvedb = new CVE();
            cvedb.cve_id = this.cveitem.cve_id;
            cvedb.vul_id = this.cveitem.cve_id;

            log.d(this.cveitem.desc);
            if (this.cveitem.desc){
                cvedb.cve_desc = [];
                log.d(`############## build description for ${cvedb.cve_id} ###########`);
                this.cveitem.desc.forEach(function(element){
                    // log.d("####\n\n");
                    // log.d(`desc ${element}`);
                    // cvedb.cve_desc.push(ModCommon.toBase64(element));
                    cvedb.cve_desc.push(element);


                    // log.d("\n\n");
                    // log.d(`${cvedb.cve_id} >>>> ${cvedb.cve_desc}`);
                });
            }

            cvedb.cve_ref_url = [];
            cvedb.added_date = this.cveitem.added_date;
            cvedb.last_modified_date = this.cveitem.last_modified_date;
            if (this.cveitem.ref){
                // this.cveitem.ref.forEach(element => cvedb.cve_ref_url.push(ModCommon.toBase64(element)));
                this.cveitem.ref.forEach(element => cvedb.cve_ref_url.push(element));
            }
            //tag
            if (this.cveitem.tag){
                this.cveitem.tag.forEach(element => cvedb.tag.push(element));
            }
            // source
            if (this.cveitem.source){
                cvedb.source.push(this.cveitem.source);
            }
            if (this.cveitem.impact){
                cvedb.cve_impact = ModCommon.toBase64(this.cveitem.impact);
            }
            if (this.cveitem.vectorAttack){               
                cvedb.cve_accessVector = this.cveitem.vectorAttack;
            }
            if (this.cveitem.vectorString){
                cvedb.cve_vectorString = this.cveitem.vectorString;
            }
            if (this.cveitem.baseScore){
                cvedb.cve_baseScore = this.cveitem.baseScore;
            }
            if (this.cveitem.exploitabilityScore){
                cvedb.cve_exploitabilityScore = this.cveitem.exploitabilityScore;
            }
            if (this.cveitem.impactScore){
                cvedb.cve_impactScore = this.cveitem.impactScore;
            }
            if (this.cveitem.severity){
                cvedb.cve_severity= this.cveitem.severity;
            }
            await cvedb.save();
            log.i(`Added ${this.cveitem.cve_id} OK`);
            // TODO: handle error case
        }
    // });
    }.bind({cveitem:Object.assign({}, item)}));
    return errno.ErrNone;
}

function cveDB2cveItem(cvedb, item = null){
    var cve_item = item;
    if (!cve_item){
        cve_item = ModCVEItem.buildItem();
    }
    // TODO: validate info

    cve_item.cve_id = cvedb.cve_id;
    cve_item.vul_id = cvedb.vul_id;
    // cvedb.cve_desc.forEach(desc => cve_item.desc.push(ModCommon.fromBase64(desc)));
    cvedb.cve_desc.forEach(desc => cve_item.desc.push(desc));
    // cvedb.cve_ref_url.forEach(ref => cve_item.ref.push(ModCommon.fromBase64(ref)));
    cvedb.cve_ref_url.forEach(ref => cve_item.ref.push(ref));
    cve_item.source = cvedb.source;
    cvedb.tag.forEach(tag => cve_item.tag.push(tag));
    return cve_item;
}

function getAll(page = 1, perpage = 5, callback = null){
    log.i("Get all cves");
    log.d(`page ${page}, perpage ${perpage}`)
    ModDb.connectdbsync(null);
    CVE.count(function(err, count) {
        if (err) {
            log.e("Get all failed, cannot count");
            log.e(err);
            return;
        }
        log.d(`CVE count ${count}`);
        var totalpages = (count/perpage + 1) | 0;
        // var totalpages = (page + 1)*perpage >= count;
        log.d(`totalpages ${totalpages}`);
        CVE.find({})
            // .sort('vul_id',1)
            .skip((page-1) * perpage)
            .limit(perpage)
            .exec(function(err, cves){

            var cve_items = [];
            if (cves){
                log.i("Found cves");
                cves.forEach(function(element){
                    log.i(`found cve ${element.cve_id}`);
                    var item = cveDB2cveItem(element);
                    // item = ModCVEItem.buildItem();
                    // item.cve_id = element.cve_id;
                    // element.cve_desc.forEach(desc => item.desc.push(ModCommon.fromBase64(desc)));
                    // item.source = element.cve_source;
                    
                    cve_items.push(item);
                    
                });
            }
            else{
                log.i("not found any cve");
            }
            
            callback(cve_items, totalpages);
        });
    });
}

function search(keyword, page = 1, perpage = 5, callback = null, fields=null){
    log.d(`Search keyword: ${keyword}`);
    let regex = new RegExp(keyword,'i');
    const filterd = CVE.find(
        { $or: [{cve_id: regex },{cve_desc: regex}] }
        )
        .skip((page-1) * perpage)
        .limit(perpage)
        .exec(function(err, cves){

            var cve_items = [];
            if (cves){
                log.i("Found cves");
                cves.forEach(function(element){
                    log.i(`found cve ${element.cve_id}`);
                    var item = cveDB2cveItem(element);
                    // item = ModCVEItem.buildItem();
                    // item.cve_id = element.cve_id;
                    // element.cve_desc.forEach(desc => item.desc.push(ModCommon.fromBase64(desc)));
                    // item.source = element.cve_source;
                    
                    cve_items.push(item);
                    
                });
            }
            else{
                log.i("not found any cve");
            }
            var totalpages = (cve_items.length/perpage + 1) | 0;
            callback(cve_items, totalpages);
        });
}

module.exports.add = add;
module.exports.getAll = getAll;
module.exports.search = search;