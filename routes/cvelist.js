/**
 * Copyright (C) 2022 Anh Huy Ngo - All Rights Reserved
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * 
 * Author: Anh Ngo
 * Created Date: 
 */


 'use strict';
////////////////////////////////////////////////////////////////////
// MODULE LOADING
////////////////////////////////////////////////////////////////////


var COMMON = require("../common");

var PROJECT_DB = require("../model/project/project_db");
var MODULE_CTRL = require("../controller/module_ctrl");
var CVE_CTRL = require("../controller/cve_ctrl");
var CVE_IMPORT_CTRL = require("../controller/cve_import_ctrl");
var APP = require("../app");
var ERR = require("../errno");
var DB = require('../db/db');
////////////////////////////////////////////////////////

////////////
// GLOBAL VARIABLES
////////////////////////////////////////////////////////////////////

var log = require("../log").build("cvelist");

const PARAM_PAGE = 'page';
const PARAM_PERPAGE = 'perpage';
const PARAM_SEARCH_KEY = 'key';
const PARAM_SEARCH_CONDITION = 'cond';
const PARAM_SEARCH_IN = 'in'; // cve, module, project, etc.
const PARAM_FILTER_PRJ = 'prj'; // use with search in
const PARAM_FILTER_COMP = 'comp';
const PARAM_FILTER_MODULE = 'mod';
const PARAM_FILTER_CVE = 'cve';
const PARAM_FILTER_SRC = 'src';
const PARAM_FILTER_TAG = 'tag';
const PARAM_FILTER_IMPORT = 'import';
const PARAM_SEARCH_FIELD = 'field'; // i.e. id, moduleId, etc.
const PARAM_SEARCH_FIELD_ID = 'id'; // i.e. id, moduleId, etc.
const PARAM_SEARCH_FIELD_NAME = 'name'; // i.e. id, moduleId, etc.
const PARAM_SEARCH_FIELD_TAG = 'tag'; // i.e. id, moduleId, etc.
const PARAM_SEARCH_FIELD_VULID = 'vulid'; // i.e. id, moduleId, etc.



var paramlist=[
    PARAM_PAGE
    ,PARAM_PERPAGE
    ,PARAM_SEARCH_CONDITION
    ,PARAM_SEARCH_KEY
    ,PARAM_SEARCH_IN
    ,PARAM_FILTER_PRJ
    ,PARAM_FILTER_COMP
    ,PARAM_FILTER_COMP
    ,PARAM_FILTER_MODULE
    ,PARAM_FILTER_CVE
    ,PARAM_FILTER_SRC
    ,PARAM_FILTER_TAG
    ,PARAM_FILTER_IMPORT
    ,PARAM_SEARCH_FIELD
];

const DEFAULT_PER_PAGE = 5;

////////////////////////////////////////////////////////////////////
// FUNCTION
////////////////////////////////////////////////////////////////////

/**
 * Query infor for filter, like list of project, module, import id
 * @returns Promise
 */
function queryFilterInfo(){
    var projects = [];
    var modules = [];
    var imports = [];
    log.d(`queryFilterInfo`);
    return new Promise((resolve, reject) => {

        log.d(`Query projects`);
        PROJECT_DB.getListProject()
        .then(items => {

            log.d(`Query projects done query module`);
            items.forEach(element => projects.push(element));
            return MODULE_CTRL.getList();
        })
        .then(items => {
            log.d(`Query module done query import`);
            items.forEach(element => modules.push(element));
            return CVE_IMPORT_CTRL.getList2();
        })
        .then(items => {
            items.forEach(element => imports.push(element));
            log.d(`Got all query info`);
            resolve({
                projects:projects,
                modules:modules,
                imports:imports,
            })
        })
        .catch(err => {
            log.e(`Query filter info failed ${err}`);
            reject(err);
        })
        ;
    });
}

/**
 * Handle request
 * @param {*} req 
 * @param {*} res 
 * @param {*} next 
 */
function handleReq(req, res, next){
    log.d("handleReq");

    // query info for filter, like projects list, module list, import list, etc.
    queryFilterInfo()
        .then(queryInfo => {
            res.render('cvelist', {
            projects:queryInfo.projects.map(function(item){
                return {
                    id:item.id,
                    name:item.name
                }
            }),

            modules:queryInfo.modules.map(function(item){
                return {
                    id:item.id,
                    name:item.name
                }
            }),

            imports:queryInfo.imports.map(function(item){
                return {
                    id:item.id,
                    importId:item.importId,
                    importIdShort:item.importId.substr(0,7),
                    name:item.title
                }
            }),
        })
        ;
    })
    .catch(err => {
        log.e(`Query filter failed ${err}`);
        // TODO: fix me please
        APP.responseMsg(res, ERR.ErrFailed, `${err}`);
    });
    
}

/**
 * Extract cond param
 * @param {*} condition 
 * @returns 
 */
function extractSearchCondition(condition){
    log.d(`extractSearchCondition ${condition}`);
    var searchKeyList = [];
    var searchKeyStr = "";
    var searchIn = "";
    var searchField = "";
    if (!COMMON.isEmpty(condition)){
        [searchKeyStr, searchIn, searchField] = condition.split('|');
        if (!COMMON.isEmpty(searchKeyStr)){
            searchKeyList = searchKeyStr.split(',');
        }
    }
    
    
    log.d(`searchKeyStr ${searchKeyStr}`);
    log.d(`searchIn ${searchIn}`);
    log.d(`searchField ${searchField}`);
    
    var cond = {
        searchKeys:searchKeyList,
        searchIn:searchIn,
        searchField:searchField
    }
    console.log(cond);
    return cond;
}

/**
 * Handle search result
 * @param {*} res 
 * @param {*} page 
 * @param {*} perpage 
 * @param {*} cves 
 * @param {*} total 
 */
function handleSearchResult(res, page, perpage, cves, total){
    log.d(`handleSearchResult`);
    
    var idx = (page - 1)*perpage + 1;
    var totalpages = (total/perpage + (total%perpage == 0?0:1)) | 0;
    log.d(`total ${total} perpage ${perpage} totalpages ${totalpages}, idx ${idx}, number items ${cves.length}`);
    res.json({
        totalpages:totalpages,
        page:page,
        startIdx:idx,
        total:total,
        cves:cves.map(function(cve){
            log.dumpArray(cve.modules, `Module list of ${cve.vul_number}`);
            return {
                idx:idx++,
                id:cve.id,
                vul_number:cve.vul_number,
                cve_number:cve.cve_number,
                desc:cve.getDesc(),
                ref:cve.getRef(),
                tags:cve.tag,
                source:cve.source,
                modules:cve.modules,
                projects:cve.projects,
                importId:cve.importId,
            }})                    
    });
}

/**
 * Handle post request
 * URL param:
 * - cond=<keyword>|<project, import, cve, module, etc.>|<field like id, etc.>
 *   keyword: can be multiple keyword, separate by comma, and seach with "OR" condition (cond: keyword 1 OR keyword 2, etc.)
 *   Support multiple "cond", search with AND condition (cond 1 AND cond 2)
 * - page=? : page number
 * @param {*} req 
 * @param {*} res 
 * @param {*} next 
 */
function handlePost(req, res, next){
    log.d("handlePost");

    var page = 1;
    var perpage = DEFAULT_PER_PAGE;
    if (req.query.hasOwnProperty(PARAM_PAGE)){
        page = req.query[PARAM_PAGE];
    }

    // TODO: implement perpage later, temporary fix 50 items per page
    // if (req.query.hasOwnProperty(PARAM_PERPAGE)){
    //     perpage = req.query[PARAM_PERPAGE];
    // }
    log.d(`page ${page} perpage ${perpage}`);


    var searchConditions=null; // format: keyword|<in, like project>|<field, like ID>

    // check if url contain search condition. If not, assume to get all cves
    
    if (req.query.hasOwnProperty(PARAM_SEARCH_CONDITION)){
        searchConditions = req.query[PARAM_SEARCH_CONDITION];
    }
    else{
        searchConditions = "|cve|"; // default search condition, search all in cve list
    }
    var searchConditionList = [];
    log.d(`searchConditions ${searchConditions}`);

    // check if it has many "cond"
    // in a cond: OR
    // among code: AND
    if (Array.isArray(searchConditions)){
        searchConditions.forEach(element => {
            searchConditionList.push(extractSearchCondition(element));
        });
    }
    else{
        searchConditionList.push(extractSearchCondition(searchConditions));
    }

    // IF only one cond, paging directly when query db
    // IF has multiple cond, query all items, load to RAM, then do paging
    // FIXME: it's not good for memory consumption when load all items to RAM, need method to improve it
    var reqPage = page;
    if (searchConditionList.length > 1){
        reqPage = -1;
    }
    // query all cond
    var requests = searchConditionList.map(cond => {
        return new Promise((resolve, reject) => {
            var searchIn = cond.searchIn;
            var searchField = cond.searchField;
            var searchKey = cond.searchKeys;
            log.d(`searchIn: ${searchIn}`);
            log.d(`searchField: ${searchField}`);
            log.d(`searchKey: ${searchKey}`);
            switch (searchIn){
                case PARAM_FILTER_PRJ:

                    if (searchField == PARAM_SEARCH_FIELD_ID){
                        log.d(`Get CVE list by project id ${searchKey}`);
                        CVE_CTRL.getCVEListByProjectId(searchKey, reqPage, perpage).then((result) => {
                            log.d(`Get CVE list by project callback`);
                            resolve(result);
                        });
                    }
                    // else if (searchField == PARAM_SEARCH_FIELD_NAME){

                    // }
                    // else if (searchField == PARAM_SEARCH_FIELD_TAG){

                    // }
                    // else if (searchField == PARAM_SEARCH_FIELD_VULID){

                    // }
                    else{
                        reject(COMMON.buildError(`Not support project field ${searchField}`, ERR.ErrInvalid));
                    }
                    break;
                case PARAM_FILTER_MODULE:

                    if (searchField == PARAM_SEARCH_FIELD_ID){
                        log.d(`Get CVE list by module id ${searchKey}`)
                        CVE_CTRL.getCVEListByModule(searchKey, reqPage, perpage).then((result) => {
                            log.d(`Get CVE list by module callback`);
                            resolve(result);
                        });
                    }
                    else{
                        reject(COMMON.buildError(`Not support module field ${searchField}`, ERR.ErrInvalid));
                    }
                    break;
                case PARAM_FILTER_CVE:
                    log.d(`Get CVE List all by keyword ${searchKey}`);
                    CVE_CTRL.getCVEList(searchKey, reqPage, perpage).then((result) => {
                        log.d(`Get CVE list callback`);
                        resolve(result);
                    })
                    .catch((err) => {
                        reject(err);
                    })
                    ;
                
                    break;
                case PARAM_FILTER_IMPORT:

                    log.d(`Get CVE List all by import ${searchKey}`);
                    CVE_CTRL.getVulByImport(searchKey, reqPage, perpage).then((result) => {
                        log.d(`Get CVE list callback`);
                        resolve(result);
                    })
                    .catch((err) => {
                        reject(err);
                    })
                    ;
                
                    break;
                default:
                    reject(COMMON.buildError(`Not support field ${searchIn}`, ERR.ErrInvalid));
                    break;
            }
        });
    });

    Promise.allSettled(requests)
        .then((results) => {
            var cveList = {};
            var total = 0;
            var totalpages = 0;
            var totalFound = 0;
            var totalSkip = 0;
            var idx = 0;
            var length = results.length;
            var cves = [];
            log.d(`handle post allSettled, length ${length}`);
            // if only one condition, return result
            if (length == 1){
                if (results[0].status == "rejected"){
                    log.e(`Reject`);
                    var [msg, code, data] = COMMON.parseError(results[0].reason);
                    APP.responseMsg(res, code, msg);
                    return;
                }
                else{
                    [cves, total, totalpages] = DB.extractQueryResult(results[0].value)
                }
            }
            else{ // if multiple condition, do paging basing on query result
                for (idx = 0; idx < length; idx++){
                    log.d(`Result ${idx}: ${results[idx].status}`);
                    if (results[idx].status == "rejected"){
                        log.e(`Reject`);
                        var [msg, code, data] = COMMON.parseError(results[idx].reason);
                        APP.responseMsg(res, code, msg);
                        return;

                    }
                    else{ // only return item exist in all cond query result.
                        // FIXME: it's just work, improve it please.
                        var cves = results[idx].value.items;
                        if (!COMMON.isEmpty(cves))
                        {
                            if (idx == 0){
                                log.d(`1st time, dict empty`);
                                
                                cves.forEach(element => {

                                    log.d(`add ${element.id} to list`);
                                    cveList[element.id] = element;
                                    total += 1;
                                });
                                
                                totalFound = total;
                            }
                            else{
                                var tmpList = {};
                                cves.forEach(element => {

                                    totalFound += 1;
                                    if (!cveList.hasOwnProperty(element.id)){
                                        log.d(`Not exist ${element.id}, delete it`);
                                        delete cveList[element.id];
                                        total -= 1;
                                        totalSkip += 1;
                                    }
                                    else{
                                        log.d(`exist ${element.id}, keep it`);
                                        tmpList[element.id] = element;
                                    }
                                });
                                cveList = tmpList;
                            }
                        }
                        else{
                            cveList = {};
                            total = 0;
                            break;
                        }
                        
                    }
                }
                // TODO: may consume a lots of memory. Optimize: search result should contain id of vul only, and query detail later.
                // TODO: need to balance between memory consumption and performance.
                var allcves = Object.values(cveList);
                total = allcves.length;
                var startIdx = (page - 1)*perpage;
                var endIdx = startIdx + perpage;
                log.d(`startIdx ${startIdx}`);
                log.d(`endIdx ${endIdx}`);
                
                cves = allcves.slice(startIdx, endIdx < total?endIdx:total);
                
            }
            log.d(`total ${total}`);
            log.d(`totalpages ${totalpages}`);
            
            handleSearchResult(res, page, perpage, cves, total);

        })
        .catch((err) => {
            var [msg, code, data] = COMMON.parseError(err);
            APP.responseMsg(res, code, msg);
        })

        
        ;
 

}

////////////////////////////////////////////////////////////////////
// MODULE EXPORT
////////////////////////////////////////////////////////////////////
module.exports.handleReq = handleReq;
module.exports.handlePost = handlePost;
module.exports.handleSearchResult = handleSearchResult;
module.exports.extractSearchCondition = extractSearchCondition;
module.exports.queryFilterInfo = queryFilterInfo;
module.exports.ROUTE_NAME = "list";