/**
 * Copyright (C) 2022 Anh Huy Ngo - All Rights Reserved
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * 
 * Author: Anh Ngo
 * Created Date: 
 */
'use strict';
////////////////////////////////////////////////////////////////////
// MODULE LOADING
////////////////////////////////////////////////////////////////////

var CRYPTO = require('./crypto');
var ERR = require('./errno');
const FS = require('fs');
const READLINE = require('readline');

var PATH = require('path');
var OS = require('os');
////////////////////////////////////////////////////////////////////
// GLOBAL VARIABLES
////////////////////////////////////////////////////////////////////

var log = require('./log').build("common");


var rootpath = PATH.resolve(__dirname);
////////////////////////////////////////////////////////////////////
// FUNCTION
////////////////////////////////////////////////////////////////////

function currentTimeMs(){
    return Date.now ();
};


function sleep(ms){
    return new Promise((resolve) => {
        setTimeout(resolve, ms);
      });
}
function isEmpty(str){
    return (!str || str.length === 0 || (str === undefined))
}

function isDictEmpty(dict) {
    return (!dict || (Object.keys(dict).length === 0) || (dict === undefined));
}

////////////////////////////////////////////////////////////////////
// MODULE EXPORT
////////////////////////////////////////////////////////////////////
exports.currentTimeMs = currentTimeMs;

exports.getTimeString = function(ms, format=""){
    return (new Date(ms)).toISOString();
}

exports.sleep = function(ms){
     sleep(ms);
}

exports.busywait = function(loop){
    while(loop-- > 0);
}

exports.toBase64 = function(str){
    log.d(`base64 ${str}`);
    // TODO: check str
    return Buffer.from(str).toString('base64');
}

/**
 * Convert base64 string to string
 * @param {*} base64str 
 */
exports.fromBase64 = function(base64str){
    log.d(`frombase64 ${base64str}`);
    return Buffer.from(base64str, 'base64').toString('utf-8');
}

exports.isStrEmpty = function(str){
    return (!str || str.length === 0 || (str === undefined))
}


exports.isEmpty = isEmpty
exports.isDictEmpty = isDictEmpty

exports.getListFromString = function (str, separate=","){
    log.d(`getListFromString '${str}', separater '${separate}'`)
    var items = [];
    if (!isEmpty(str)){
        items = str.split(separate);
    }
    var ret = items != null?items:[];
    log.d(ret);
    return ret;
}

const STRID_TYPE_SHA1 = "sha1";
const STRID_TYPE_STR = "str";
exports.str2strId = function(str, type=STRID_TYPE_SHA1){
    var strid = null;
    
    switch(type){
        case STRID_TYPE_SHA1:
            strid = CRYPTO.sha1String(str.toLowerCase().replace(/ /g, ""));
            break;
        case STRID_TYPE_STR:
            strid = str.toLowerCase().replace(/[ :]/g, "");
            break;
        default:
            log.e(`String to id failed, invalid type '${type}'`);
            strid = null;
            break;
    }
    // TODO: newline, etc.???
    log.d(`str2strId ${str} -> ${strid}`);
    return strid;

}

exports.STRID_TYPE_SHA1 = STRID_TYPE_SHA1;
exports.STRID_TYPE_STR = STRID_TYPE_STR;


exports.readFileLineByLine = function(fpath){

    log.i(`readFileLineByLine ${fpath}`);

    return new Promise((resolve, reject) => {
        if (!FS.existsSync(fpath)){
            log.e(`File '${fpath} not exist'`);
            reject(ERR.ErrNotExist);
            return;
        }
        const fileStream = FS.createReadStream(fpath);
    
        const rl = READLINE.createInterface({
          input: fileStream,
          crlfDelay: Infinity,
        });
        // Note: we use the crlfDelay option to recognize all instances of CR LF
        // ('\r\n') in input.txt as a single line break.
        const alllines = [];

        fileStream.once('error', _ => reject(ERR.ErrFailed));
        const lines = [];
        rl.on('line', line => {
                    log.d(`line: ${line}`);
                    lines.push(line);
                    // log.d(lines);
            }
            );
        rl.on('close', _ => {
            log.d(`realine callback ${lines}`);
            resolve(lines);
        
        });
    })

}

exports.writeLinesToFiles = function(fpath, lines, appended=false){
    var ret = ERR.ErrNone;
    log.i(`writeLinesToFiles ${fpath}`);

    try {
        var options = null;
        if (!appended){
            options = {flag:'w'};
        }
        else{
            options = {flag:'a+'};
        }
        // var data = lines.join(OS.EOL);
        // // data += "\n";
        // log.d(`Data to write '${data}'`);
        // FS.writeFileSync(fpath, data, options);
        // FS.writeFileSync(fpath, "\n", options);
        lines.forEach(element => {
            FS.writeFileSync(fpath, OS.EOL + element, options);
        });
        ret = ERR.ErrNone;
      } catch (err) {
        log.e(err);
        ret = ERR.ErrException;
      }
    return ret;
}



exports.setAppRoot = function(path){
    rootpath = path;
}
exports.getPathFromRoot = function (relpath=""){
    return PATH.join(rootpath, relpath);
}

exports.getRelLocation = function(fullpath, root = null){
    log.d(`getRelLocation ${fullpath}`);
    if (root == null){
        root = rootpath;
    }
    var relativePath = PATH.relative(root, fullpath);
    log.d(`root ${root}`);
    log.d(`relativePath ${relativePath}`);
    return relativePath;
}

// class ValError extends Error{
//     constructor(msg, code = ERR.ErrFailed, data=null, options = null){
//         super(msg, options);
//         this.code = code;
//         this.data = data;
//     }
// }

exports.buildError = function(msg, code = ERR.ErrFailed, data=null, err=null){
    return new ERR.ValError(msg, code, data, {cause:err});
}
exports.parseError = function(err){
    if (err instanceof ERR.ValError){
        return [err.message, err.code, err.data, err.cause];
    }
    else{
        return [err.message, ERR.ErrUnknown, null, err.cause];
    }
}


exports.MAP_STATE_UNMAP = 0; // unmap
exports.MAP_STATE_MAPPED = 1; // mapped
exports.MAP_STATE_DELETED = -1; // deleted
